<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Krislee的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Krislee的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Krislee的个人博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Krislee的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Krislee的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/面向对象的JS-设计模式（1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/面向对象的JS-设计模式（1/" itemprop="url">面向对象的JS-设计模式（1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T14:31:38+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="#js1"><strong>面向对象编程风格</strong></a></li>
<li><a href="#js2"><strong>封装</strong></a></li>
<li><a href="#js3"><strong>继承</strong></a></li>
<li><a href="#js4"><strong>多态</strong></a></li>
</ul>
<hr>
<p><span id="js1"><strong>编程风格</strong></span></p>
<p>面向对象变成就是将你的需求抽象成一个对象，然后针对这个对象分析其特征(属性)与动作(方法)。这个对象我们称之为类。面向对象编程思想其中一个特点就是封装，就是说把你需要的功能放在一个对象里。</p>
<p><span id="js2"><strong>封装</strong></span></p>
<p>在js中创建一个类很容易，首先声明一个函数保存在一个变量里。按编程习惯，一般将这个代表类的变量名首字母大写。然后在这个函数(类)的内部通过对this(函数内部自带的一个变量，用于指向当前这个对象)变量添加属性或者方法来实现对类添加属性或者方法,例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span> (<span class="params">id,bookname,price</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">	<span class="keyword">this</span>.bookname = bookname;</span><br><span class="line">	<span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过原型的方式来实现，在JS中类、函数都是一个对象，所以也有原型prototype。在原型上添加属性和方法有两种</p>
<p><em>一种是一一为原型对象属性赋值，另一种则是将一个对象赋值给类的原型对象</em></p>
<p>######ps:这两种方式不要混用.</p>
<ul>
<li><p>一</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book..prototype.display = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>二</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book.prototype = &#123;</span><br><span class="line">    display:function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>***
</code></pre><p><strong>封装好了类，那么我们如何使用？</strong></p>
<p>我们不能直接使用这个Book类、需要用new关键字来实例化(创建)新的对象。使用实例化对象的属性或者方法时，可以通过点语法访问，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Book = function (id,bookname,price)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.bookname = bookname;</span><br><span class="line">	this.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var book = new Book(10,&quot;js高级进阶&quot;,88.88);</span><br><span class="line"></span><br><span class="line">console.log(book.bookname); // js高级进阶</span><br></pre></td></tr></table></figure>
<p><em>问题：那么通过this添加的属性和方法同在prototype中添加的属性和方法有什么区别呢？</em></p>
<p>通过this添加的属性、方法是在当前对象上添加的，然而JavaScipt是一种基于原prototype的语言，所以每创建一个对象时，她都有一个prototype用于指向其继承的属性、方法。</p>
<p>这样通过prototype继承的方法并不是对象自身的，所以在使用这些方法时，需要通过prototype一级一级查找来得到。这样你就会发现通过this定义的属性或者方法是该对象自身拥有的，所以我们每次通过类创建一个新对象，this指向的属性和方法都会得到相应的创建，而通过prototype继承的属性或者方法是每个对象通过prototype访问到，所以我们每次通过类创建一个新对象时这些属性和方法不会再次创建。</p>
<p><em>问题：在java中有public 、 private等关键字来创建 公共，私有变量，那么JS里也有吗？如果没有JS如何实现呢？</em></p>
<p>首先你需要这么几点…</p>
<ol>
<li>js的函数(类)是 原型 prototype</li>
<li>js的函数级作用域，在作用域内声明的变量，外部是访问不到的</li>
<li>但是函数作用域内this创建的属性和方法,在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。</li>
<li>this创建的方法可以访问函数内私有的属性和私有的方法。</li>
</ol>
<p>那么接下来，我们来看一下这个demo。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span> (<span class="params">id, name,price</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//私有属性</span></span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//私有方法</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">checkId</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">	<span class="comment">//特权方法</span></span><br><span class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.getPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.setPrice = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//对象公有属性</span></span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="comment">//对象公有方法</span></span><br><span class="line">	<span class="keyword">this</span>.copy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">	<span class="keyword">this</span>.setNmae(name);</span><br><span class="line">	<span class="keyword">this</span>.setPrice(price);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样我们就可以理解了，通过JS函数级作用域的特征来实现在函数内部创建外部访问不到的私有化变量和私有方法。</strong></p>
<p><strong>通过new关键字实例化对象时，由于对类执行一次，所以类的内部this上定义的属性和方法自然就可以复制到新创建的对象上，成为对象公有化的属性与方法，而其中一些方法能访问到类的私有属性和方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var b = new Book(11,&apos;jsvascript设计模式&apos;,50);</span><br><span class="line"></span><br><span class="line">console.log(b.num); //undefined</span><br><span class="line"></span><br><span class="line">console.log(b.isChinses); //undefined</span><br><span class="line"></span><br><span class="line">console.log(b.id); //11</span><br><span class="line">console.log(b.isJSBook);//false</span><br></pre></td></tr></table></figure>
<p><strong>闭包的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var Book = (function()&#123;</span><br><span class="line"></span><br><span class="line">	//静态私有变量</span><br><span class="line">	var bookNum = 0 ;</span><br><span class="line">	//静态私有方法</span><br><span class="line">	function checkBook(name)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//返回构造函数</span><br><span class="line">	return function(newId,newName,newPrice)&#123;</span><br><span class="line">		//私有变量</span><br><span class="line">		var name,price;</span><br><span class="line">		//私有方法</span><br><span class="line">		function checkID(id)&#123;&#125;</span><br><span class="line">		//特权方法</span><br><span class="line">		this.getName = function()&#123;</span><br><span class="line">			console.log(&quot;1111&quot;)</span><br><span class="line">		&#125;;</span><br><span class="line">		this.getPrice = function()&#123;&#125;;</span><br><span class="line">		this.setName = function()&#123;&#125;;</span><br><span class="line">		this.setPrice = function()&#123;&#125;;</span><br><span class="line">		//公有属性</span><br><span class="line">		this.id = newId;</span><br><span class="line">		//公有方法</span><br><span class="line">		this.copy = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">		bookNum++;</span><br><span class="line"></span><br><span class="line">		if(bookNum &gt; 2)&#123;</span><br><span class="line">			throw new Error(&apos;heiheihei&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">		//构造器</span><br><span class="line">		this.setName(name);</span><br><span class="line">		this.setPrice(price);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// //构造原型</span><br><span class="line">	// _book.prototype = &#123;</span><br><span class="line">	// 	//静态公有属性</span><br><span class="line">	// 	isJSBook : false,</span><br><span class="line">	// 	display :function()&#123;&#125;;</span><br><span class="line">	// &#125;;</span><br><span class="line"></span><br><span class="line">	// //返回类</span><br><span class="line"></span><br><span class="line">	// return _book;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Book.prototype=&#123;</span><br><span class="line">	isJSBook : false,</span><br><span class="line">	display : function()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>“闭包是有权访问另外一个函数作用域中变量的函数，<strong>即-在一个函数内部创建另一个函数</strong>，我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量,如<strong>bookNum</strong>这个变量。此时这个变量叫静态私有变量。”</p>
<p>“但是，在闭包外部添加原型属性和方法看上去像似脱离了闭包这个类…”</p>
<p>“所以有时候在闭包内部实现一个完整的类然后将其返回”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var Book = (function()&#123;</span><br><span class="line"></span><br><span class="line">	//静态私有变量</span><br><span class="line">	var bookNum = 0 ;</span><br><span class="line">	//静态私有方法</span><br><span class="line">	function checkBook(name)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//返回构造函数</span><br><span class="line">	return function(newId,newName,newPrice)&#123;</span><br><span class="line">		//私有变量</span><br><span class="line">		var name,price;</span><br><span class="line">		//私有方法</span><br><span class="line">		function checkID(id)&#123;&#125;</span><br><span class="line">		//特权方法</span><br><span class="line">		this.getName = function()&#123;</span><br><span class="line">			console.log(&quot;1111&quot;)</span><br><span class="line">		&#125;;</span><br><span class="line">		this.getPrice = function()&#123;&#125;;</span><br><span class="line">		this.setName = function()&#123;&#125;;</span><br><span class="line">		this.setPrice = function()&#123;&#125;;</span><br><span class="line">		//公有属性</span><br><span class="line">		this.id = newId;</span><br><span class="line">		//公有方法</span><br><span class="line">		this.copy = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">		bookNum++;</span><br><span class="line"></span><br><span class="line">		if(bookNum &gt; 2)&#123;</span><br><span class="line">			throw new Error(&apos;heiheihei&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">		//构造器</span><br><span class="line">		this.setName(name);</span><br><span class="line">		this.setPrice(price);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//构造原型</span><br><span class="line">	_book.prototype = &#123;</span><br><span class="line">		//静态公有属性</span><br><span class="line">		isJSBook : false,</span><br><span class="line">		display :function()&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//返回类</span><br><span class="line"></span><br><span class="line">	return _book;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>instanceof</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Book = function (title,time,type)&#123;</span><br><span class="line">	if(this instanceof Book)&#123;</span><br><span class="line">		this.title = title;</span><br><span class="line">		this.time = time;</span><br><span class="line">		this.type = type;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return new Book(title,time,type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var book = Book(&apos;JAVASCRIPT&apos;,&apos;2004&apos;,&apos;JS&apos;);</span><br></pre></td></tr></table></figure>
<p>这样即便没new出来关键字也同样可以出结果</p>
<p><span id="js3"><strong>继承</strong></span></p>
<p>JS作为面向对象的弱类型语言，继承也是其非常强大的特性之一。那么如何在JS中实现继承呢？<br>首先先创建一个父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name)&#123;</span><br><span class="line">	//属性</span><br><span class="line">	this.name = name || &apos;Animal&apos;;</span><br><span class="line">	this.pro = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];</span><br><span class="line">	//实例方法</span><br><span class="line">	this.sleep = function ()&#123;</span><br><span class="line">		console.log(this.name + &apos;正在睡觉&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原型方法</span><br><span class="line"></span><br><span class="line">Animal.prototype.eat = function(food)&#123;</span><br><span class="line">	console.log(this.name + &apos;正在吃&apos; + food);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><p><em>核心： 将父类的实例作为子类的原型</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line">Cat.prototype.name = &apos;cat&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Test Code </span><br><span class="line"></span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.eat(&apos;fish&apos;));</span><br><span class="line">cat.sleep();</span><br><span class="line">console.log(cat instanceof Animal);</span><br><span class="line">console.log(cat instanceof Cat);</span><br></pre></td></tr></table></figure>
<p>打印结果….<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat</span><br><span class="line">cat正在吃fish</span><br><span class="line">undefined</span><br><span class="line">cat正在睡觉</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">[ &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;5&apos; ]</span><br></pre></td></tr></table></figure></p>
<p><strong>优点</strong></p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p><strong>构造继承</strong></p>
<p><em>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">	Animal.call(this);</span><br><span class="line">	this.name = name || &apos;Tome&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Test code </span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">cat.sleep();</span><br><span class="line">console.log(cat instanceof Animal);</span><br><span class="line">console.log(cat instanceof Cat);</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tome</span><br><span class="line">Tome正在睡觉</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>解决了1中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ol>
<p><strong>实例继承</strong></p>
<p><em>核心：为父类实例添加新特性，作为子类实例返回</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">	var instance = new Animal();</span><br><span class="line">	instance.name = name || &apos;Tome&apos;;</span><br><span class="line">	return instance ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Test code </span><br><span class="line"> var cat = new Cat();</span><br><span class="line"> console.log(cat.name);</span><br><span class="line"> cat.sleep();</span><br><span class="line"> console.log(cat instanceof Animal);  // true</span><br><span class="line"> console.log(cat instanceof Cat); // false</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果</li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>实例是父类的实例，不是子类的实例</li>
<li>不支持多继承</li>
</ul>
<p><strong>拷贝继承</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">	var animal = new Animal();</span><br><span class="line">	for (let p in animal)&#123;</span><br><span class="line">		Cat.prototype[p] = animal[p];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Cat.prototype.name = name || &apos;tom&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test code </span><br><span class="line"></span><br><span class="line">var cat = new Cat();</span><br><span class="line"></span><br><span class="line">console.log(cat.name);</span><br><span class="line">cat.sleep();</span><br><span class="line">console.log(cat instanceof Animal); // false</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>支持多继承</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>效率较低，内存占用高（因为要拷贝父类的属性）</li>
<li>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</li>
</ol>
<p><strong>组合继承</strong></p>
<p><em>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">	Animal.call (this);</span><br><span class="line">	this.name = name || &apos;TOM&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">//test-code </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var cat = new Cat();</span><br><span class="line"></span><br><span class="line">console.log(cat.name);</span><br><span class="line">cat.sleep();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); // true</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<p><strong>寄生组合继承</strong></p>
<p><em>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name)&#123;</span><br><span class="line">	Animal.call(this);</span><br><span class="line">	this.name = name || &apos;kris&apos;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function ()&#123;</span><br><span class="line">	//创建一个没有实例方法的类</span><br><span class="line">	var Super = function()&#123;&#125;</span><br><span class="line">	Super.prototype = Animal.prototype;</span><br><span class="line">	//将实例作为子类的原型</span><br><span class="line">	Cat.prototype = new Super();</span><br><span class="line"></span><br><span class="line">	Cat.prototype.constructor = Cat;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">cat.sleep();</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); //true</span><br></pre></td></tr></table></figure>
<p><span id="js4"><strong>多态</strong></span></p>
<p>在面向对象编程中，还有一种特性叫做多态。所谓多态其实就是同一个方法多种调用方式。<br>只不过在JS中要对传入的参数做判断以实现多种调用方式，如我们定义一个add方法…如果不传则返回10，传了1个参数则+10，传了两个参数，就把结果相加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// function add()&#123;</span><br><span class="line">// 	var arg = arguments</span><br><span class="line"></span><br><span class="line">// 	len = arg.length;</span><br><span class="line"></span><br><span class="line">// 	switch(len)&#123;</span><br><span class="line">// 		case 0:</span><br><span class="line">// 		return 10;</span><br><span class="line">// 		case 1 :</span><br><span class="line">// 		return 10 + arg[0];</span><br><span class="line">// 		case 2 :</span><br><span class="line">// 		return arg[0]+arg[1];</span><br><span class="line">// 	&#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// console.log(add())</span><br><span class="line">// console.log(add(5));</span><br><span class="line">// console.log(add(6,7));</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以转化为我们认为简而有效的类的形式…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Add()&#123;</span><br><span class="line">	function zero()&#123;</span><br><span class="line">		return 10;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function one(num)&#123;</span><br><span class="line">		return 10 + num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function two(num1,num2)&#123;</span><br><span class="line">		return num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.add = function()&#123;</span><br><span class="line">		var arg = arguments;</span><br><span class="line">		len = arg.length;</span><br><span class="line"></span><br><span class="line">		switch(len)&#123;</span><br><span class="line">			case 0:</span><br><span class="line">			 return zero();</span><br><span class="line">			 case 1 :</span><br><span class="line">			 return one(arg[0] + 10);</span><br><span class="line">			 case 2 :</span><br><span class="line">			 // console.log(&quot;222&quot;)</span><br><span class="line">			 return two(arg[0],arg[1])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var A = new Add();</span><br><span class="line"></span><br><span class="line">console.log(A.add());</span><br><span class="line">console.log(A.add(5));</span><br><span class="line">console.log(A.add(6,7));</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/JS的运行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/JS的运行机制/" itemprop="url">JS的运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-28T11:02:52+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://upload-images.jianshu.io/upload_images/5531021-069f3a0866e9392d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sc1105.jpeg"></p>
<h3 id="为什么JavaScript是单线程"><a href="#为什么JavaScript是单线程" class="headerlink" title="为什么JavaScript是单线程"></a>为什么JavaScript是单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p>
<p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。也称之为<strong>宏任务</strong></li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。这样的任务队列也叫<strong>微任务</strong></li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p><strong>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</strong></p>
<h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p><em>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</em></p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p>图转引自<a href="https://vimeo.com/96425312" target="_blank" rel="noopener">Philip Roberts的演讲《Help, I’m stuck in an event-loop》</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5531021-816b9f0082bf9110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg2014100802.png"></p>
<p>主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function()&#123;console.log(2);&#125;,1000);</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure>
<p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;console.log(1);&#125;, 0);</span><br><span class="line">console.log(2);</span><br></pre></td></tr></table></figure>
<p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p>
<p>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;定时器开始啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">    for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">        i == 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&apos;执行then函数啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure>
<p>那么这个执行结果是什么呢？？？</p>
<p><em>[马上执行for循环拉 — 代码执行结束  — 执行then函数拉 — 定时器开始啦]</em></p>
<ol>
<li>整体script作为第一个宏任务进入主线程，这是第一轮宏任务。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中，这是第二个宏任务。</li>
<li>继续执行，打印【马上执行for循环啦】</li>
<li>遇到promise.then()微任务，这是第一轮宏任务下的微任务，因为整体script是第一轮宏任务嘛</li>
<li>继续执行，打印【代码执行结束】</li>
<li>现在整体script作为第一轮宏任务，去检查这一轮下的微任务，发现有一个promise.then()，去执行它</li>
</ol>
<p>（至此现在第一轮宏任务，以及这一轮宏任务下的微任务都被执行过了）<br>7.开始第二轮宏任务，发现宏任务队列里有一个setTimeout，执行它，就打印了【定时器开始啦】</p>
<h3 id="Node-js的Event-Loop"><a href="#Node-js的Event-Loop" class="headerlink" title="Node.js的Event Loop"></a>Node.js的Event Loop</h3><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5531021-b005065c20b85aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg20141008031.png"></p>
<p>根据上图，Node.js的运行机制如下。</p>
<p>（1）V8引擎解析JavaScript脚本。</p>
<p>（2）解析后的代码，调用Node API。</p>
<p>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</p>
<p>（4）V8引擎再将结果返回给用户。</p>
<p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function A() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(function timeout() &#123;</span><br><span class="line">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class="line">&#125;, 0)</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function ()&#123;</span><br><span class="line">  setImmediate(function A() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    setImmediate(function B()&#123;console.log(2);&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  setTimeout(function timeout() &#123;</span><br><span class="line">    console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;);</span><br><span class="line">// 1</span><br><span class="line">// TIMEOUT FIRED</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>
<p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）</p>
<p>原文请查看<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/git原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/git原理/" itemprop="url">git原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T08:50:20+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果你不是太懂git…那么你可以通过阅读<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官网</a>来使用。这里讲解的git浅显易懂。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先，让我们创建一个项目目录，并进入该目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-project</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd my-project</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>这里的<code>git init</code> 只做一件事，就是在项目根目录下创建一个.git的子目录，用来保存版本信息。<br><img src="https://upload-images.jianshu.io/upload_images/5531021-c3a3f78d6d07cc88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-11-06 上午9.06.33.png"></p>
<h3 id="保存对象"><a href="#保存对象" class="headerlink" title="保存对象"></a>保存对象</h3><p>接下来，新建一个空文件 <strong>test.txt</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br></pre></td></tr></table></figure>
<p>然后，把这个文件加入git仓库，也就是为test。txt的当前内容创建一个副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git hash-object -w test.txt</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，git hash-object命令把test。txt的当前内容压缩成二进制文件，存入Git。压缩后的二进制文件，称为一个Git对象，保存在.git/objects目录。</p>
<p>这个命令还会计算当前内容的SHA1 哈希值（长度40的字符串）作为该对象的文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -R .git/objects</span><br><span class="line"></span><br><span class="line">.git/objects/e6:</span><br><span class="line">9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure>
<p>上面代码可以看到，.git/objects下面多了一个子目录，目录名是哈希值的前2个字符，该子目录下面有一个文件，文件名是哈希值的后38个字符。</p>
<p>再看一下这个文件的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure>
<p>上面代码输出的文件内容，都是一些二进制字符。你可能会问，test.txt是一个空文件，为什么会有内容？这是因为二进制对象里面还保存一些元数据。</p>
<p>如果想看该文件原始的文本内容，要用git cat-file命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br></pre></td></tr></table></figure>
<p>因为原始文件是空文件，所以上面的命令什么也看不到，现在向test.txt写入一些内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;hello world&apos; &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>因为文件内容已经改变，需要将它再次保存成Git对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git hash-object -w test.txt</span><br><span class="line"></span><br><span class="line">3b18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br></pre></td></tr></table></figure>
<p>上面代码可以看到，随着内容改变，test.txt的哈希值已经变了。同时，新文件.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad 也已经生成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>文件保存成二进制对象以后，还需要通知 Git 哪些文件发生了变动。所有变动的文件，Git 都记录在一个区域，叫做”暂存区”（英文叫做 index 或者 stage）。等到变动告一段落，再统一把暂存区里面的文件写入正式的版本历史。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index //用于在暂存区记录一个发生变动的文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">3b18e512dba79e4c8300dd08aeb37f8e728b8dad test.txt</span><br></pre></td></tr></table></figure>
<p>上面命令向暂存区写入文件名test.txt、二进制对象名（哈希值）和文件权限。</p>
<p>git ls-files命令可以显示暂存区当前的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files --stage</span><br><span class="line"></span><br><span class="line">100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0   test.txt</span><br></pre></td></tr></table></figure>
<p>上面代码表示，暂存区现在只有一个文件test.txt，以及它的二进制对象名和权限。知道了二进制对象名，就可以在.git/objects子目录里面读出这个文件的内容。</p>
<p>git status命令会产生更可读的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">    新文件：   test.txt</span><br></pre></td></tr></table></figure>
<h3 id="git-add命令"><a href="#git-add命令" class="headerlink" title="git add命令"></a>git add命令</h3><p>上面两步（保存对象和更新暂存区），如果每个文件都做一遍，那是很麻烦的。Git 提供了git add命令简化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all  // git add .</span><br></pre></td></tr></table></figure>
<p>上面命令相当于，对当前项目所有变动的文件，执行前面的两步操作。</p>
<h3 id="commit的概念"><a href="#commit的概念" class="headerlink" title="commit的概念"></a>commit的概念</h3><p>暂存区保留本次变动的文件信息，等到修改了差不多了，就要把这些信息写入历史，这就相当于生成了当前项目的一个快照（snapshot）。</p>
<p>项目的历史就是由不同时点的快照构成。Git 可以将项目恢复到任意一个快照。快照在 Git 里面有一个专门名词，叫做 commit，生成快照又称为完成一次提交。</p>
<p>下文所有提到”快照”的地方，指的就是 commit。</p>
<h3 id="完成提交"><a href="#完成提交" class="headerlink" title="完成提交"></a>完成提交</h3><p>首先，设置一下用户名和 Email，保存快照的时候，会记录是谁提交的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot; </span><br><span class="line">$ git config --global user.email &quot;Email 地址&quot;</span><br></pre></td></tr></table></figure>
<p>接下来，要保存当前的目录结构。前面保存对象的时候，只是保存单个文件，并没有记录文件之间的目录关系（哪个文件在哪里）。</p>
<p><strong>git write-tree</strong>命令用来将当前的目录结构，生成一个 Git 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git write-tree</span><br><span class="line"></span><br><span class="line">c3b8bb102afeca86037d5b5dd89ceeb0090eae9d</span><br></pre></td></tr></table></figure>
<p>上面代码中，目录结构也是作为二进制对象保存的，也保存在.git/objects目录里面，对象名就是哈希值。</p>
<p>git commit-tree命令用于将目录树对象写入版本历史。</p>
<p>git log命令也可以用来查看某个快照信息。</p>
<h3 id="git-commit命令"><a href="#git-commit命令" class="headerlink" title="git commit命令"></a>git commit命令</h3><p>Git 提供了git commit命令，简化提交操作。保存进暂存区以后，只要git commit一个命令，就同时提交目录结构和说明，生成快照。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
<p>此外，还有两个命令也很有用</p>
<ul>
<li>git checkout命令用于切换到某个快照。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</span><br></pre></td></tr></table></figure>
</li>
<li><p>git show命令用于展示某个快照的所有代码变动。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</span><br></pre></td></tr></table></figure>
<h3 id="branch的概念"><a href="#branch的概念" class="headerlink" title="branch的概念"></a>branch的概念</h3><p>到了这一步，还没完。如果这时用git log命令查看整个版本历史，你看不到新生成的快照。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>上面命令没有任何输出，这是为什么呢？快照明明已经写入历史了。</p>
<p>原来git log命令只显示当前分支的变动，虽然我们前面已经提交了快照，但是还没有记录这个快照属于哪个分支。</p>
<p>所谓分支（branch）就是指向某个快照的指针，分支名就是指针名。哈希值是无法记忆的，分支使得用户可以为快照起别名。而且，分支会自动更新，如果当前分支有新的快照，指针就会自动指向它。比如，master 分支就是有一个叫做 master 指针，它指向的快照就是 master 分支的当前快照。</p>
<p>用户可以对任意快照新建指针。比如，新建一个 fix-typo 分支，就是创建一个叫做 fix-typo 的指针，指向某个快照。所以，Git 新建分支特别容易，成本极低。</p>
<p>Git 有一个特殊指针HEAD， 总是指向当前分支的最近一次快照。另外，Git 还提供简写方式，HEAD^指向 HEAD的前一个快照（父节点），HEAD~6则是HEAD之前的第6个快照。</p>
<p>每一个分支指针都是一个文本文件，保存在.git/refs/heads/目录，该文件的内容就是它所指向的快照的二进制对象名（哈希值）。</p>
<h3 id="更新分支"><a href="#更新分支" class="headerlink" title="更新分支"></a>更新分支</h3><p>git log的运行过程是这样的：</p>
<ol>
<li>查找HEAD指针对应的分支，本例是master</li>
<li><p>找到master指针指向的快照，本例是 785f188674ef3c6ddc5b516307884e1d551f53ca</p>
</li>
<li><p>找到父节点（前一个快照）c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</p>
</li>
<li>以此类推，显示当前分支的所有快照</li>
</ol>
<p><strong>最后，补充一点。前面说过，分支指针是动态的。原因在于，下面三个命令会自动改写分支指针。</strong></p>
<ul>
<li>git commit：当前分支指针移向新创建的快照。</li>
<li>git pull：当前分支与远程分支合并后，指针指向新创建的快照。</li>
<li>git reset [commit_sha]：当前分支指针重置为指定快照。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://medium.com/@shalithasuranga/how-does-git-work-internally-7c36dcb1f2cf" target="_blank" rel="noopener">How does git work internally</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/redux思想写微信小程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/redux思想写微信小程序/" itemprop="url">redux思想写微信小程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T23:20:26+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/JavaScript数据可视化库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/JavaScript数据可视化库/" itemprop="url">JavaScript数据可视化库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T21:09:10+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="在前端的开发中…数据是枯燥的，但是图形的展示却是有趣的。有些时候我们需要借助一些三方的js库来实现数据可视化。让用户更加直观的看透数据的变化更替。下面我们列出如下："><a href="#在前端的开发中…数据是枯燥的，但是图形的展示却是有趣的。有些时候我们需要借助一些三方的js库来实现数据可视化。让用户更加直观的看透数据的变化更替。下面我们列出如下：" class="headerlink" title="在前端的开发中…数据是枯燥的，但是图形的展示却是有趣的。有些时候我们需要借助一些三方的js库来实现数据可视化。让用户更加直观的看透数据的变化更替。下面我们列出如下："></a>在前端的开发中…数据是枯燥的，但是图形的展示却是有趣的。有些时候我们需要借助一些三方的js库来实现数据可视化。让用户更加直观的看透数据的变化更替。下面我们列出如下：</h6><h3 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h3><p><strong>star 数：80K</strong></p>
<p>它允许你将任意数据绑定到文档对象模型（DOM），然后在文档上应用数据转换。</p>
<p><a href="https://github.com/d3/d3/blob/master/API.md" target="_blank" rel="noopener">这里是D3的API</a></p>
<p><strong>如果使用npm</strong></p>
<figure class="highlight plain"><figcaption><span>install d3```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**你也可以加载d3使用如下： d3js.org, CDNJS, or unpkg.**</span><br></pre></td></tr></table></figure>
<p><script src="https://d3js.org/d3.v5.js"></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><script src="https://d3js.org/d3.v5.min.js"></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>import * as d3 from “d3”;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>import {scaleLinear} from “d3-scale”;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**在node里**</span><br></pre></td></tr></table></figure></p>
<p>var d3 = require(“d3”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然你也可以按模块加载使用Object.assign</span><br><span class="line"></span><br><span class="line">```var d3 = Object.assign(&#123;&#125;, require(&quot;d3-format&quot;), require(&quot;d3-geo&quot;), require(&quot;d3-geo-projection&quot;));</span><br></pre></td></tr></table></figure></p>
<p>这里有一个很棒的例子 ：<a href="https://github.com/d3/d3/wiki/Gallery" target="_blank" rel="noopener">https://github.com/d3/d3/wiki/Gallery</a></p>
<p>项目地址：<a href="https://github.com/d3/d3/" target="_blank" rel="noopener">https://github.com/d3/d3/</a></p>
<h3 id="ChartJS"><a href="#ChartJS" class="headerlink" title="ChartJS"></a>ChartJS</h3><p><strong>star 数：40K</strong></p>
<p>一个非常受欢迎的开源 HTML5 图表库，它使用画布元素构建响应式 Web 应用。ChartJS 提供了混合图表类型，新的图表轴类型和漂亮的动画。它的设计简单而优雅，有 8 种基本的图表类型，你可以将该库与 moment.js 结合在一起使用，用于渲染时间轴。</p>
<p>如果项目中使用的是react，这里有<a href="https://github.com/reactjs/react-chartjs" target="_blank" rel="noopener">react-chartjs</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var LineChart = require(&quot;react-chartjs&quot;).Line;</span><br><span class="line"></span><br><span class="line">var MyComponent = React.createClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;LineChart data=&#123;chartData&#125; options=&#123;chartOptions&#125; width=&quot;600&quot; height=&quot;250&quot;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>项目地址：<a href="https://cdnjs.com/libraries/Chart.js" target="_blank" rel="noopener">https://cdnjs.com/libraries/Chart.js</a></p>
<h3 id="ThreeJS"><a href="#ThreeJS" class="headerlink" title="ThreeJS"></a>ThreeJS</h3><p>ThreeJS 用 WebGL 创建 3d 动画。该项目的灵活性和抽象性意味着它也可用于 2 维或 3 维的数据可视化。</p>
<p>使用方法：<br><a href="https://threejs.org/build/three.min.js" target="_blank" rel="noopener">下载微型库</a>并包含在你的html代码中，同样你可以使用npm，通过install 然后import 在你的模块中，二者选一，这也取决你如何搭建你的项目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/three.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h6 id="这段代码创建一个场景、一个摄像机和一个几何立方体，并将立方体添加到场景中。然后，它为场景和摄像机创建一个WebGL渲染器，并将该视图添加到文档中。body元素。最后，它为摄像机动画场景中的立方体。"><a href="#这段代码创建一个场景、一个摄像机和一个几何立方体，并将立方体添加到场景中。然后，它为场景和摄像机创建一个WebGL渲染器，并将该视图添加到文档中。body元素。最后，它为摄像机动画场景中的立方体。" class="headerlink" title="这段代码创建一个场景、一个摄像机和一个几何立方体，并将立方体添加到场景中。然后，它为场景和摄像机创建一个WebGL渲染器，并将该视图添加到文档中。body元素。最后，它为摄像机动画场景中的立方体。"></a>这段代码创建一个场景、一个摄像机和一个几何立方体，并将立方体添加到场景中。然后，它为场景和摄像机创建一个WebGL渲染器，并将该视图添加到文档中。body元素。最后，它为摄像机动画场景中的立方体。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var camera, scene, renderer;</span><br><span class="line">var geometry, material, mesh;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line">function init() &#123;</span><br><span class="line"></span><br><span class="line">	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );</span><br><span class="line">	camera.position.z = 1;</span><br><span class="line"></span><br><span class="line">	scene = new THREE.Scene();</span><br><span class="line"></span><br><span class="line">	geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );</span><br><span class="line">	material = new THREE.MeshNormalMaterial();</span><br><span class="line"></span><br><span class="line">	mesh = new THREE.Mesh( geometry, material );</span><br><span class="line">	scene.add( mesh );</span><br><span class="line"></span><br><span class="line">	renderer = new THREE.WebGLRenderer( &#123; antialias: true &#125; );</span><br><span class="line">	renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">	document.body.appendChild( renderer.domElement );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animate() &#123;</span><br><span class="line"></span><br><span class="line">	requestAnimationFrame( animate );</span><br><span class="line"></span><br><span class="line">	mesh.rotation.x += 0.01;</span><br><span class="line">	mesh.rotation.y += 0.02;</span><br><span class="line"></span><br><span class="line">	renderer.render( scene, camera );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Echarts-amp-Highcharts"><a href="#Echarts-amp-Highcharts" class="headerlink" title="Echarts &amp; Highcharts"></a>Echarts &amp; Highcharts</h3><p><strong>star 数：30K</strong></p>
<p>百度的 Echarts 项目是一个基于浏览器的交互式图表和可视化库。它是用纯 JavaScript 编写的，基于 zrender 画布。它支持以画布、SVG(4.0+) 和 VML 的形式绘制图表。除了 PC 和移动浏览器外，ECharts 还可以与 node 上的 node-canvas 一起使用，以便进行高效的服务器端渲染（SSR）。</p>
<p>这也是个人比较推荐的项目…因为也是有比较清晰和明确的中文文档。</p>
<p>echarts可以个性化自定义定制属于自己的主题，地址如下：<br><a href="http://echarts.baidu.com/theme-builder/#acc-line-body" target="_blank" rel="noopener">http://echarts.baidu.com/theme-builder/#acc-line-body</a></p>
<p>库的下载地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://echarts.baidu.com/download.html</span><br></pre></td></tr></table></figure>
<p><strong>Highcharts</strong></p>
<p><strong>star 数：8K</strong></p>
<p>Highcharts JS 是一个广受欢迎的基于 SVG 的 JavaScript 图表库，针对旧的浏览器可降级到 VML 和画布。世界上最大的 100 家公司中，有 72 家公司（Facebook、Twitter 等）使用了这个库，这使得它成为世界上最流行的 JS 图表 API。</p>
<p>项目地址:<br><a href="https://github.com/highcharts/highcharts" target="_blank" rel="noopener">https://github.com/highcharts/highcharts</a></p>
<h3 id="Metric-Graphics"><a href="#Metric-Graphics" class="headerlink" title="Metric-Graphics"></a>Metric-Graphics</h3><p><strong>star 数：7K</strong></p>
<p>Metric-Graphics 用于可视化和布局时间序列数据。它相对较小（80kb），提供了小而优雅的线条图、散点图、直方图、柱状图和数据表，以及地格图（rug plot）和基本线性回归等特性。</p>
<p>这里有一个交互式的示例库：</p>
<p><a href="https://metricsgraphicsjs.org/examples.htm" target="_blank" rel="noopener">https://metricsgraphicsjs.org/examples.htm</a></p>
<p>项目地址：</p>
<p><a href="https://github.com/metricsgraphics/metrics-graphics" target="_blank" rel="noopener">https://github.com/metricsgraphics/metrics-graphics</a></p>
<h3 id="Recharts"><a href="#Recharts" class="headerlink" title="Recharts"></a>Recharts</h3><p>Recharts 是一个使用 React 和 D3 构建的图表库，可以作为声明性的 React 组件使用。 该库提供原生 SVG 支持，轻量级依赖树（D3 子模块）高度可定制。官网文档中可以找到很多例子。</p>
<p>项目地址：</p>
<p><a href="https://github.com/recharts/recharts" target="_blank" rel="noopener">https://github.com/recharts/recharts</a></p>
<h3 id="Raphael"><a href="#Raphael" class="headerlink" title="Raphael"></a>Raphael</h3><p><strong>star 数：10K</strong></p>
<p>Raphael 是一个 JavaScript 矢量库，可在 Web 中绘制矢量图形。该库使用 SVG W3C 和 VML 作为创建图形的基础，因此每个图形对象也是 DOM 对象，你可以附加 JavaScript 事件处理程序。Raphael 目前支持 Firefox 3.0+、Safari 3.0+、Chrome 5.0+、Opera 9.5+ 和 Internet Explorer 6.0+。</p>
<p>项目地址：</p>
<p><a href="https://github.com/DmitryBaranovskiy/raphael" target="_blank" rel="noopener">https://github.com/DmitryBaranovskiy/raphael</a></p>
<h3 id="C3js"><a href="#C3js" class="headerlink" title="C3js"></a>C3js</h3><p><strong>star 数：8K</strong></p>
<p>C3 是一个基于 D3 的可重用 Web 应用图表库。该库为每个元素提供了相应的类，这样你就可以通过这些类来自定义样式，并通过 D3 直接扩展结构。它还提供了多种 API 和回调来访问图表状态。借助它们，你可以更新图表，即使是已经渲染好的图标。</p>
<p>看看这些例子：<a href="https://c3js.org/examples.html" target="_blank" rel="noopener">https://c3js.org/examples.html</a></p>
<p>项目地址：<a href="https://github.com/c3js/c3" target="_blank" rel="noopener">https://github.com/c3js/c3</a></p>
<h3 id="React-Vis"><a href="#React-Vis" class="headerlink" title="React Vis"></a>React Vis</h3><p><strong>star 数：4K</strong></p>
<p>React-vis 是 Uber 开发的一系列数据可视化组件，包括线 / 面 / 柱状图、热图、散热图、等高线图、六角热图等等。使用该库不需要事先掌握 D3 或任何其他 data-vis 库的知识，并提供了低级模块化的构建块组件，如 x/y 轴。</p>
<p>项目地址：<a href="https://github.com/uber/react-vis" target="_blank" rel="noopener">https://github.com/uber/react-vis</a></p>
<h3 id="React-Virtualized"><a href="#React-Virtualized" class="headerlink" title="React Virtualized"></a>React Virtualized</h3><p><strong>star 数：12K</strong></p>
<p>React virtualized 是一组 React 组件，有效地呈现大型列表和表格数据。ES6、CommonJS 和 UMD 版本可以在每个分发版中使用，该项目支持 Webpack 4 工作流。请注意，为了避免版本冲突，必须将 react，react-dom 指定为 peer 依赖。</p>
<p>项目地址：<a href="https://github.com/bvaughn/react-virtualized" target="_blank" rel="noopener">https://github.com/bvaughn/react-virtualized</a></p>
<h3 id="Victory"><a href="#Victory" class="headerlink" title="Victory"></a>Victory</h3><p><strong>star 数：6K+</strong></p>
<p>Victory 在 Web 和 React Native 应用程序中使用相同的 API，以便于跨平台绘制图表。一种优雅而灵活的方式来利用 React 组件来支持实用的数据可视化。</p>
<p>项目地址：</p>
<p><a href="https://github.com/FormidableLabs/victory" target="_blank" rel="noopener">https://github.com/FormidableLabs/victory</a></p>
<h3 id="CartoDB"><a href="#CartoDB" class="headerlink" title="CartoDB"></a>CartoDB</h3><p><strong>star 数：2K</strong></p>
<p>Carto 是一个位置智能和数据可视化工具，用于发现位置数据中的见解。你可以通过 Web 表单上传地理空间数据（Shapefiles、GeoJSON 等），并在数据集或地图上将其可视化，使用 SQL 进行搜索，并使用 CartoCSS 来应用地图样式。</p>
<p>这里有一些视频演示：<a href="https://vimeo.com/channels/carto" target="_blank" rel="noopener">https://vimeo.com/channels/carto</a></p>
<p>项目地址：<a href="https://github.com/CartoDB/cartodb" target="_blank" rel="noopener">https://github.com/CartoDB/cartodb</a></p>
<h3 id="Raw-graphs"><a href="#Raw-graphs" class="headerlink" title="Raw graphs"></a>Raw graphs</h3><p><strong>star 数：5K</strong></p>
<p>Raw 是电子表格和数据可视化之间的连接，基于 d3.js 库创建基于向量的自定义可视化。它可以处理表格数据（电子表格和 CSV）和从其他应用程序复制和粘贴的文本。因为是 SVG 格式，所以可以使用矢量图形编辑器编辑，或直接嵌入到网页中。</p>
<p>这里有一个例子：<a href="https://rawgraphs.io/gallery/" target="_blank" rel="noopener">https://rawgraphs.io/gallery/</a></p>
<p>项目地址：</p>
<p><a href="https://github.com/densitydesign/raw" target="_blank" rel="noopener">https://github.com/densitydesign/raw</a></p>
<h3 id="Metabase"><a href="#Metabase" class="headerlink" title="Metabase"></a>Metabase</h3><p><strong>star 数：11K+</strong></p>
<p>Metabase 是一种相当快速和简单的方法，可以在不了解 SQL 的情况下创建数据仪表盘（分析师和数据专业人士可使用 SQL 模式）。 你可以创建片段和度量指标，发送数据到 Slack（通过 MetaBot 在 Slack 中查看数据）等等。它可能是一个很好的工具，可用它在团队内部可视化数据，尽管可能需要做一些维护工作。</p>
<p>项目地址：</p>
<p><a href="https://github.com/metabase/metabase" target="_blank" rel="noopener">https://github.com/metabase/metabase</a></p>
<h3 id="tauCharts"><a href="#tauCharts" class="headerlink" title="tauCharts"></a>tauCharts</h3><p><strong>star 数：2K</strong></p>
<p>tauCharts 一个基于 D3 的图表库。该库提供了一个声明接口，用于将数据字段快速映射到可视化属性，它的架构允许你使用插件构建切面和扩展图表行为。</p>
<p>项目地址：</p>
<p><a href="https://github.com/TargetProcess/tauCharts" target="_blank" rel="noopener">https://github.com/TargetProcess/tauCharts</a></p>
<h3 id="原文链接：https-blog-bitsrc-io-11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727"><a href="#原文链接：https-blog-bitsrc-io-11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727" class="headerlink" title="原文链接：https://blog.bitsrc.io/11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727"></a>原文链接：<a href="https://blog.bitsrc.io/11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727" target="_blank" rel="noopener">https://blog.bitsrc.io/11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/微信小程序8月开发记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/微信小程序8月开发记录/" itemprop="url">微信小程序8月开发记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T23:37:12+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="8月份在两个星期左右的时间开发了两款小程序，急冲冲的上线了。也算是带着bug上线吧。这里把用到的技术归纳总结一下。"><a href="#8月份在两个星期左右的时间开发了两款小程序，急冲冲的上线了。也算是带着bug上线吧。这里把用到的技术归纳总结一下。" class="headerlink" title="8月份在两个星期左右的时间开发了两款小程序，急冲冲的上线了。也算是带着bug上线吧。这里把用到的技术归纳总结一下。"></a>8月份在两个星期左右的时间开发了两款小程序，急冲冲的上线了。也算是带着bug上线吧。这里把用到的技术归纳总结一下。</h6><h4 id="UI库"><a href="#UI库" class="headerlink" title="UI库"></a>UI库</h4><p>这里我们选择用到的是IView的UI库，功能多，选择多，样式也相对较全面。这里我们之后也会封装自己的component开源库。</p>
<h5 id="github"><a href="#github" class="headerlink" title="github"></a>github</h5><p><a href="https://github.com/TalkingData/iview-weapp" target="_blank" rel="noopener">IView</a></p>
<h5 id="官网地址（使用说明）"><a href="#官网地址（使用说明）" class="headerlink" title="官网地址（使用说明）"></a>官网地址（使用说明）</h5><p><a href="https://weapp.iviewui.com/docs/guide/start" target="_blank" rel="noopener">官网地址</a></p>
<p>用法上参考component官方用法。</p>
<h4 id="wxParse"><a href="#wxParse" class="headerlink" title="wxParse"></a>wxParse</h4><p>首先是项目中用到的富文本解析…这里安利一个github的js库,<a href="https://github.com/icindy/wxParse" target="_blank" rel="noopener">wxParse</a>,这也是我个人非常喜欢的小程序富文本解析库。</p>
<p>可以实现html，markdown等解析成小程序的可视方案。用法等非常简单易懂。</p>
<h4 id="canvas的绘图方案"><a href="#canvas的绘图方案" class="headerlink" title="canvas的绘图方案"></a>canvas的绘图方案</h4><p><a href="https://github.com/kuckboy1994/mp_canvas_drawer" target="_blank" rel="noopener">canvas绘图方案地址</a></p>
<p>这里其实把绘图的api简单易懂的封装了一层。方法使用上，则可以参考在css上我们通常简单易懂的position的用法，absolute…然后在绘图地址上随意定位，然后实现了canvas绘图，保存图片分享的方案</p>
<h4 id="随机验证码的生成"><a href="#随机验证码的生成" class="headerlink" title="随机验证码的生成"></a>随机验证码的生成</h4><p><a href="https://github.com/krislee94/checkcodeJS" target="_blank" rel="noopener">随机验证码的JS库地址</a></p>
<p>用法上：</p>
<h5 id="wxml"><a href="#wxml" class="headerlink" title="wxml:"></a>wxml:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;image-check&quot;&gt; </span><br><span class="line">           &lt;canvas class=&apos;canvas&apos; style=&quot;width:200rpx;height:110rpx;&quot; canvas-id=&quot;canvas&quot; bindtap=&apos;onReady&apos;&gt;&lt;/canvas&gt;</span><br><span class="line">       &lt;/view&gt;</span><br></pre></td></tr></table></figure>
<h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Mcaptcha(&#123;</span><br><span class="line">  el: &apos;canvas&apos;,</span><br><span class="line">  width: 87,//对图形的宽高进行控制</span><br><span class="line">  height: 55,</span><br><span class="line">  code: num</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="同声翻译"><a href="#同声翻译" class="headerlink" title="同声翻译"></a>同声翻译</h4><p>这里没有用到什么技术特点，直接用到的是小程序插件，大家到时候直接搜索就好。</p>
<h4 id="腾讯视频"><a href="#腾讯视频" class="headerlink" title="腾讯视频"></a>腾讯视频</h4><p>这里没有用到什么技术特点，直接用到的是小程序插件，大家到时候直接搜索就好。(有广告，头疼)</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>wxParse的全局样式别放在app.wxss里，因为这样会影响IView的样式上的使用。</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>更新于2018年9月10号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/react-高阶组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/react-高阶组件/" itemprop="url">react-高阶组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-11T09:42:35+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><p>在React组件的构建过程中，常常有这样的场景，有一类功能需要被不同的组件公用，此时，就涉及抽象的话题，在不同设计理念下，有许多的抽象方法，而针对React，我们重点讨论两种：mixin和高阶组件。<br><img src="https://upload-images.jianshu.io/upload_images/5531021-60fd010022847f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="png"></p>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>mixin的特性一直广泛存在于各种面向对象语言中。比如在Ruby中，include关键词即是mixin。是将一个模块混入到一个另一个模块中，或是一个类中。</p>
<p>为什么编程语言要引入这样一种特性呢？</p>
<p>事实上，包括C++等一些年龄较大的OOP语言，它们都有一个强大但危险的多重继承特性。在现代语言中，为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有很多不方便的地方，为了弥补缺失，java引入了接口interface。其他一些语言则引入了像mixin的技巧。</p>
<h3 id="封装mixin方法"><a href="#封装mixin方法" class="headerlink" title="封装mixin方法"></a>封装mixin方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const mixin = function(obj,mixins)&#123;</span><br><span class="line">	const newObj = obj;</span><br><span class="line"></span><br><span class="line">	newObj.prototype = Object.create(obj.prototype);</span><br><span class="line"></span><br><span class="line">	for(let prop in mixins)&#123;</span><br><span class="line">		if(mixins.hasOwnProperty(prop))&#123;</span><br><span class="line">			newObj.prototype[prop] = mixins[prop];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const BigMixin = &#123;</span><br><span class="line">	fly:()=&gt;&#123;</span><br><span class="line">		console.log(&apos;I can fly&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Big = function()&#123;</span><br><span class="line">	console.log(&apos;new big&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const FlyBig = mixin(Big,BigMixin);</span><br><span class="line"></span><br><span class="line">const flyBig = new FlyBig();  //=&gt;&apos;new big&apos;</span><br><span class="line"> </span><br><span class="line">flyBig.fly(); //=&gt; &apos;I can fly&apos;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，我们不难看出，对于广义的mixin方法，就是用赋值的方式将mixin对象里的方法都挂载到原对象上，来实现对对象的混入。</p>
<p>从上述的实现，我们可以联想到 underscore库中的extend 或 lodash库中的 assign方法，或者说ES6中的Object.assign()方法。</p>
<h3 id="在react中使用mixin"><a href="#在react中使用mixin" class="headerlink" title="在react中使用mixin"></a>在react中使用mixin</h3><p>在官方封装的’reat-addons-pure-render-mixin’；在git上没找到相关的有价值的库，应该是react认为mixin是一种反模式形式。</p>
<p>但是发现了react-immutable-render-mixin这样的库。只是很久没维护了，不建议使用<br><a href="https://github.com/jurassix/react-immutable-render-mixin" target="_blank" rel="noopener">参考链接</a></p>
<p>我们可以看到，使用createClass实现的mixin为组件做了两件事。</p>
<p><strong>工具方法</strong>:这是mixin的基本功能，如果你想共享一些工具类方法，就可以定义它们，直接在各个组件中使用。<br><strong>生命周期继承</strong>:prips与state合并。这是mixin特别重要的功能，</p>
<h3 id="ES6-Classes-与-decorator"><a href="#ES6-Classes-与-decorator" class="headerlink" title="ES6 Classes 与 decorator"></a>ES6 Classes 与 decorator</h3><p>然而，使用我们推荐的ES6 classes形势构建组件时，它并不支持mixin。React文档中也未能给出解决方法。</p>
<p>要在class的基础上封装mixin，就要说到class的本质。ES6并没有改变js面向对象方法基于原型的本质，不过再次智商提供了一些语法糖。class就是其中之一。</p>
<p>对于是按mixin方法来说，这就没什么不一样了。接下来我们来聊聊另一个语法糖decorator。正巧可以用来实现class的mixin。</p>
<p>decorator 是ES7定义的新特性，与java 的 pre-defined annotation（预定义注解）相似。但与java 的annotation 不同的是，decorator是运用在运行时的方法，在Redux或其他一些应用层框架中，越来越多的使用decorator以实现对组件的修饰。</p>
<p>这样我们就可以使用@mixin。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import &#123;getOwnPropertyDescriptors&#125; from &apos;./private/utils&apos;;</span><br><span class="line"></span><br><span class="line">const &#123; defineProperty &#125; = Object;</span><br><span class="line"></span><br><span class="line">function handleClass(target,mixins)&#123;</span><br><span class="line">	if(!mixins.length)&#123;</span><br><span class="line">		throw new SyntaxError(&apos;@mixin() class .....&apos;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(let i=0;i&lt;mixins.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">		const descs = getOwnPropertyDescriptors(mixins[i]);</span><br><span class="line"></span><br><span class="line">		for(const key in descs)&#123;</span><br><span class="line">			if(!(key intarget.prototype))&#123;</span><br><span class="line">				defineProperty(target.prototype,key,descs[key])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function mixin(...mixins)&#123;</span><br><span class="line">	if(typeof mixins[0] == &apos;function&apos;)&#123;</span><br><span class="line">		return handelClass(mixins[0],[]);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		return target=&gt;&#123;</span><br><span class="line">			return handleClass(target,mixins);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，源代码十分简单，它将每一个mixin对象的方法都跌价到target 对象的原型上以达到mixin的目的，这样，就可以用@mixin来做多个重用模块的叠加了。</p>
<p>对于react，我们自然可以用上述方法来实现mixin。但不幸的是，社区从0.14版本开始渐渐开始剥离mixin。那么，到底是什么原因导致mixin成为反模式了呢？</p>
<h3 id="mixin问题"><a href="#mixin问题" class="headerlink" title="mixin问题"></a>mixin问题</h3><ul>
<li>破坏了原有组件的封装</li>
<li>命名冲突</li>
<li>增加复杂性</li>
</ul>
<p>针对这些困扰，React社区提出来新的方式来取代mixin，那就是高阶组件。</p>
<h3 id="高阶组件-Higher-Order-Components"><a href="#高阶组件-Higher-Order-Components" class="headerlink" title="高阶组件(Higher-Order Components)"></a>高阶组件(Higher-Order Components)</h3><p>高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。</p>
<p>具体来说，高阶组件是一个函数，能够接受一个组件并返回一个新的组件。</p>
<p>在我们项目中使用react-redux框架的时候，有一个<code>connect</code>的概念，这里的<code>connect</code>其实就是一个高阶组件。也包括类似react-router-dom中的withRouter的概念</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5531021-651f4f73389534eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="connect"></p>
<h3 id="构建一个简单的hoc"><a href="#构建一个简单的hoc" class="headerlink" title="构建一个简单的hoc"></a>构建一个简单的hoc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function hello ()&#123;</span><br><span class="line">    console.log(&quot;hello i  love react &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function hoc(fn)&#123;</span><br><span class="line">    return ()=&gt;&#123;</span><br><span class="line">          console.log(&quot;first&quot;);</span><br><span class="line">            fn();</span><br><span class="line">          console.log(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello = hoc(hello);</span><br><span class="line"></span><br><span class="line">hello();</span><br></pre></td></tr></table></figure>
<h3 id="实现高阶组件的方法"><a href="#实现高阶组件的方法" class="headerlink" title="实现高阶组件的方法"></a>实现高阶组件的方法</h3><p>实现高阶组件的方法有如下两种：</p>
<ul>
<li><strong>属性代理</strong>。高阶组件通过呗包裹的React组件来操作props</li>
<li><strong>反向继承</strong>。高阶组件继承于被包裹的React组件</li>
</ul>
<p>接下来我们分别来阐述这两种方法。</p>
<h4 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h4><p>属性代理是我们react中常见高阶组件的实现方法，我们通过一个例子来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React,&#123;Component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const MyContainer = (WraooedComponent) =&gt; </span><br><span class="line">	</span><br><span class="line">	class extends Component &#123;</span><br><span class="line">		render()&#123;</span><br><span class="line">			return &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从这里看到最重要部分是render 方法中返回了传入 WrappedComponent的React组件。这样，我们就可以通过高阶组件来传递props。这种方法即为属性代理。</p>
<p>自然，我们想要使用MyContainer这个高阶组件就变得非常容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class MyComponent extends Component&#123;</span><br><span class="line">	//...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MyContainer(MyComponent);</span><br></pre></td></tr></table></figure>
<p>这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。就这么简单，保持单个组件封装性的同时还保留了易用性。当然，我们也可以用decorator来转换。</p>
<p>当使用属性代理构建高阶组件时，调用顺序不同于mixin。上述执行生命周期的过程类似于堆栈调用：</p>
<p><strong>didmount -&gt;HOC didmount -&gt;(HOCs didmount)-&gt;(HOCs will unmount)-&gt;HOC will unmount -&gt; unmount</strong></p>
<h4 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h4><p>另一种构建高阶组件的方法称为反向继承，从字面意思上看，它一定与继承性相关。我们同样来看一个简单的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyContainer = (WrappedComponent)=&gt;&#123;</span><br><span class="line">	class extends WrappedComponent &#123;</span><br><span class="line">		render()&#123;</span><br><span class="line">			return super.render();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码。高阶组件返回的组件继承于 WrappedComponent 。因为被动地继承了 WrappedComponent，所有的调用都会反向，这也是种方法的由来。</p>
<p>这种方法与属性代理不太一样。它通过继承WrappedComponent来实现，方法可以通过super来顺序调用。因为依赖于继承机制。HOC的调用顺序和队列是一样的。</p>
<p><strong>didmount -&gt; HOC didmount -&gt;(HOCs didmount) -&gt; will unmount -&gt;HOC will unmount -&gt;(HOCs will unmount)</strong></p>
<p>在反向继承方法中，高阶组件可以使用 WrappedComponent 引用，这意味着它可以使用 WrappedComponent 的state 、props。生命周期和render方法。但它不能保证完整的子组件树被解析。它有两个比较大的特点，下面我们展开来讲一讲。</p>
<h5 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h5><p>渲染劫持就是指的是高阶组件可以控制 WrappedComponent的渲染过程，并渲染各种各样的结果。我们可以在这个过程中在任何React元素输出的结果中读取、增加、修改、删除props，或读取或修改React元素树，或条件显示。又或者用样式包裹元素树</p>
<h5 id="控制state"><a href="#控制state" class="headerlink" title="控制state"></a>控制state</h5><p>高阶组件可以读取、修改或删除WrappedComponent实例中的state，如果需要的话，也可以增加state。</p>
<h4 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h4><p>当包裹一个高阶组件时，我们失去了原始 WrappedComponent的displayName，而组件名字是方便我们开发与调试的重要属性。</p>
<h4 id="组件参数"><a href="#组件参数" class="headerlink" title="组件参数"></a>组件参数</h4><p>有时，我们调用高阶组件需要传入一些参数，这可以用非常简单的方式来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function HOCFactoryFactory(...params)&#123;</span><br><span class="line">	return function HOCFactory(WrappedComponent)&#123;</span><br><span class="line">		return class HOC extends Component&#123;</span><br><span class="line">			render()&#123;</span><br><span class="line">				return &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你使用的时候，可以这么写：</p>
<p><code>HOCFactoryFactory(params)(WrappedComponent)</code></p>
<p>//or</p>
<p><code>@HOCFactoryFactory(params)</code><br><code>class WrappedComponent extends React.Component{}</code></p>
<p>这也是利用了函数式编程的特征。可见，在React抽象的过程中，处处可见它的影子。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://react.css88.com/docs/higher-order-components.html" target="_blank" rel="noopener">react中文文档</a><br><a href="">深入React技术栈 作者：陈屹 出版社：人民邮电出版社</a><br><a href="https://segmentfault.com/a/1190000010371752" target="_blank" rel="noopener">深入浅出React高阶组件</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/react实现仿大众点评WebAPP-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/react实现仿大众点评WebAPP-1/" itemprop="url">react实现boss直聘app</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-26T09:24:30+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识的储备"><a href="#基础知识的储备" class="headerlink" title="基础知识的储备"></a>基础知识的储备</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p><strong>webpack</strong> 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p><a href="https://www.webpackjs.com/concepts/#%E5%85%A5%E5%8F%A3-entry-" target="_blank" rel="noopener">webpack的中文文档地址</a></p>
<p><strong>一张图理解webpack</strong><br><img src="https://upload-images.jianshu.io/upload_images/5531021-4b3412b1c2bab3e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>要理解webpack需要从四个核心概念：</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>比如在文件<em>webpack.config.js</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./app/index.js&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h4><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：</p>
<p>在<em>webpack.config.js</em>文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<h6 id="注意，loader-能够-import-导入任何类型的模块（例如-css-文件），这是-webpack-特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。"><a href="#注意，loader-能够-import-导入任何类型的模块（例如-css-文件），这是-webpack-特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。" class="headerlink" title="注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。"></a>注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。</h6><p><strong>在更高层面，在 webpack 的配置中 loader 有两个目标:</strong></p>
<ul>
<li>test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li>
<li>use 属性，表示进行转换时，应该使用哪个 loader。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure>
<h4 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h4><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<p><em>webpack.config.js</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;); // 用于访问内置插件</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: /\.txt$/, use: &apos;raw-loader&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure>
<p>更多的资料还是请查看官网。</p>
<h3 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h3><p>react基础jsx，props ，state，生命周期，组件之间的传值。</p>
<p>一些以前我写的简书文章有些是rn的，也是因为rn才接触的react</p>
<p><a href="https://www.jianshu.com/p/0b18a77f92b4" target="_blank" rel="noopener">props的一些内容</a><br><a href="https://www.jianshu.com/p/5fcf6accfacb" target="_blank" rel="noopener">react生命周期</a></p>
<h3 id="React-性能优化工具"><a href="#React-性能优化工具" class="headerlink" title="React 性能优化工具"></a>React 性能优化工具</h3><p>我们可以使用react官方的工具 <strong>react-addons-perf</strong><br>这样我们可以在index.jsx如何使用呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Perf from &apos;react-addons-perf&apos;</span><br><span class="line">if(_DEV_)&#123;</span><br><span class="line">    window.Perf = Perf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样我们在console控制台中。</strong></p>
<ul>
<li><p>输入Perf.start();</p>
</li>
<li><p>之后用户操作-&gt;一顿操作-&gt;</p>
</li>
<li><p>操作完了之后，Perf.printWasted();</p>
</li>
</ul>
<p>这样就可以看出，我们这里的性能哪里。</p>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="react-addons-pure-render-mixin"><a href="#react-addons-pure-render-mixin" class="headerlink" title="react-addons-pure-render-mixin"></a>react-addons-pure-render-mixin</h4><p>首先先导入 <code>npm install react-addons-pure-render-mixin --save</code></p>
<p>那么–save 和 –save-dev区别。 </p>
<ul>
<li>–save是项目的依赖，</li>
<li>–save-dev是我们开发的依赖。</li>
</ul>
<p>在constructor构造函数中使用。</p>
<p>this.shouldComponentUpdate = PureRendMixin.shouldComponentUpdate,.bind(this);</p>
<p>这里我们知道，react有个生命周期，生命周期是hook，叫做shouldComponentUpdate,如果我们不设置的话，那么这个生命周期里 return true，每次setState的时候，都要过一遍这个函数。</p>
<h4 id="Immutable-js-优化"><a href="#Immutable-js-优化" class="headerlink" title="Immutable.js 优化"></a>Immutable.js 优化</h4><p>Immutable.js来处理数据，实现了js的数据不可变。但是在项目中使用Immutable的成本较高，之所以不轻易使用，Immutable定义了一种新的操作数据的语法，而且每个地方都需要用。</p>
<h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><p><a href="https://www.jianshu.com/p/e06736dbac65" target="_blank" rel="noopener">react-router4 入门学习</a></p>
<h3 id="redux基础"><a href="#redux基础" class="headerlink" title="redux基础"></a>redux基础</h3><p><a href="https://www.jianshu.com/p/56e7c831cf63" target="_blank" rel="noopener">redux 1</a><br><a href="https://www.jianshu.com/p/56e7c831cf63" target="_blank" rel="noopener">redux 2</a></p>
<p>这里之后我会单独整理 redux 的内容。</p>
<h3 id="使用-fetch"><a href="#使用-fetch" class="headerlink" title="使用 fetch"></a>使用 fetch</h3><p>在传统的我们请求服务器的数据用的是ajax，因为ajax的兼容性比较好。但是在react中我们使用fetch请求 <a href="https://github.com/whatwg/fetch" target="_blank" rel="noopener">github的fetch请求</a>，使用起来，并不麻烦。一般后台的请求，较多的就是get ，post。当然还有options，put，delete等方式，这里就不过多描述。</p>
<h4 id="封装get请求"><a href="#封装get请求" class="headerlink" title="封装get请求"></a>封装get请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &apos;whatwg-fetch&apos;</span><br><span class="line">import &apos;es6-promise&apos;</span><br><span class="line"></span><br><span class="line">export function get(url) &#123;</span><br><span class="line">  var result = fetch(url, &#123;</span><br><span class="line">      credentials: &apos;include&apos;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">          &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return result;</span><br></pre></td></tr></table></figure>
<h4 id="封装post请求"><a href="#封装post请求" class="headerlink" title="封装post请求"></a>封装post请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &apos;whatwg-fetch&apos;</span><br><span class="line">import &apos;es6-promise&apos;</span><br><span class="line"></span><br><span class="line">// 将对象拼接成 key1=val1&amp;key2=val2&amp;key3=val3 的字符串形式</span><br><span class="line">function obj2params(obj) &#123;</span><br><span class="line">    var result = &apos;&apos;;</span><br><span class="line">    var item;</span><br><span class="line">    for (item in obj) &#123;</span><br><span class="line">        result += &apos;&amp;&apos; + item + &apos;=&apos; + encodeURIComponent(obj[item]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result) &#123;</span><br><span class="line">        result = result.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发送 post 请求</span><br><span class="line">export function post(url, paramsObj) &#123;</span><br><span class="line">    var result = fetch(url, &#123;</span><br><span class="line">        method: &apos;POST&apos;,</span><br><span class="line">        credentials: &apos;include&apos;,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &apos;Accept&apos;: &apos;application/json, text/plain, */*&apos;,</span><br><span class="line">            &apos;Content-Type&apos;: &apos;json&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        body: obj2params(paramsObj)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fetch的请求的data，一般是string类型，因此会采用string拼接。这里我们请求的时候尽量会使用对象类型。因此我们写一个obj2params。</p>
<p>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import &#123; get &#125; from &apos;./get.js&apos;</span><br><span class="line">import &#123; post &#125; from &apos;./post.js&apos;</span><br><span class="line"></span><br><span class="line">export function getData() &#123;</span><br><span class="line">    // &apos;/api/1&apos; 获取字符串</span><br><span class="line">    var result = get(&apos;/api/1&apos;)</span><br><span class="line"></span><br><span class="line">    result.then(res =&gt; &#123;</span><br><span class="line">        return res.text()</span><br><span class="line">    &#125;).then(text =&gt; &#123;</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // &apos;/api/2&apos; 获取json</span><br><span class="line">    var result1 = get(&apos;/api/2&apos;)</span><br><span class="line"></span><br><span class="line">    result1.then(res =&gt; &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;).then(json =&gt; &#123;</span><br><span class="line">        console.log(json)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function postData() &#123;</span><br><span class="line">    // &apos;/api/post&apos; 提交数据</span><br><span class="line">    var result = post(&apos;/api/post&apos;, &#123;</span><br><span class="line">        a: 100,</span><br><span class="line">        b: 200</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    result.then(res =&gt; &#123;</span><br><span class="line">        return res.json();</span><br><span class="line">    &#125;).then(json =&gt; &#123;</span><br><span class="line">        console.log(json)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基础知识点就以上这么多，之后的几天，每一个点都需要自己仔细看，了解其中的知识点</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://coding.imooc.com/class/99.html" target="_blank" rel="noopener">本章的知识来源-imooc实战</a></p>
<p>[深入React技术栈]</p>
<p><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack中文网</a></p>
<h6 id="2018-6-29日更改"><a href="#2018-6-29日更改" class="headerlink" title="2018/6/29日更改"></a>2018/6/29日更改</h6><p>post封装请求，result.json() 报错，result.json is not a function result是一个promise对象。</p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p><a href="https://s.wcd.im/v/2rm5dZ3g/?slv=2&amp;sid=5n79&amp;v=oosnVwkGjQjsNIBEF2BVDU_PVLQ8&amp;from=singlemessage" target="_blank" rel="noopener">测试微信小程序</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/微信web的开发总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/微信web的开发总结/" itemprop="url">微信web的开发总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T11:18:21+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近写了一个web微信端的项目。关于世界杯竞猜类的活动。对于第一次写H5有些陌生但却又有些熟悉。而且写项目的那几天很多东西也都是现学现卖。遇到的问题和解决的思路，在这里我先总结一下。<br><img src="https://upload-images.jianshu.io/upload_images/5531021-ea412b89d0afbdcb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG1.jpeg"></p>
<ul>
<li><a href="#1">1. h5移动端我们选择哪种方式</a></li>
<li><a href="#2">2. h5页面的适配问题</a></li>
<li><a href="#3">3. h5的跨域问题以及解决方案</a></li>
<li><a href="#4">4. 微信授权的一些必要知识点</a></li>
</ul>
<h3 id="1">h5移动端我们选择哪种方式</h3>

<p>传统在我们写h5页面的时候，我们会选择jquery + h5 + css 来解决。但是在移动端的时候，因为涉及到移动端的一些情况，我们选择了zepto.js来，因为zepto 是一个轻量级的库，加载项目，我们只需要使用他的api，而zepto的使用极大的参考了jquery，可以说，95%的和jquery的相似。<br><img src="https://upload-images.jianshu.io/upload_images/5531021-45ad382d4e2eed56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-06-16 下午10.23.34.png"><br><a href="http://zeptojs.com/" target="_blank" rel="noopener">更多的信息请看官网</a>。<br>通过上图其实我们不难发现，其实zeptojs的掌握只需要了解他的四大模块，第一就是core的一些方法的使用，第二就是，event 包括on()&amp;off()的处理，第三是ajax 的请求。第四就是 form表单的一些内容。</p>
<h3 id="2">h5页面的适配问题</h3>

<p>h5的适配在项目中，我们通过增加meta。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>并且在渲染的function中增加如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var html = document.documentElement;</span><br><span class="line">        var htmlWidth = html.getBoundingClientRect().width;</span><br><span class="line">        html.style.fontSize = htmlWidth / 15 + &quot;px&quot;;</span><br><span class="line">    &#125;)()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样在计算的时候，比如项目的高保真(通常是以iphone6为基准 正式宽高的两倍)测量的高度是 50，这个时候 50/50 = 1 rem 。放入实际项目中运用。当然啦，这个需要我们不断的运算。如果使用less 或 sass 的话，会极大的方便我们的使用。</p>
<p>当然这里的适配方案不唯一。</p>
<h3 id="3">h5的跨域问题以及解决方案</h3>

<p>最糟心的其实是H5的跨域问题。原本因为项目只有一天写代码的时间，而且我看内容也很简单，就没想着package.json。node_module的方式去写，更没用想过写server 去 request 后台请求给前台。</p>
<p>因为后台只支持post请求， 并且也没加入 cors ，其实最简单的方式就是后台加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);</span><br></pre></td></tr></table></figure></p>
<p>更多关于cors的信息，请看阮一峰老师的文章<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p>
<p>或者支持get请求的时候，前台请求使用jsonp的方式。</p>
<p>以上方式都不支持的时候，通常有两种方式，第一种是<strong>前端部署+nginx代理</strong>。第二种 也就是这次我使用的方式就是 使用 <strong>thymeleaf</strong>。<br><a href="https://www.cnblogs.com/topwill/p/7434955.html" target="_blank" rel="noopener">关于thymeleaf的一些用法</a>。<br>写习惯了react项目，习惯了MVVM的方式。但是thymeleaf是很典型的mvc的模式，在control层写入请求，把数据response或者放置在model层中，前端直接拿数据使用渲染View层。</p>
<h3 id="4">微信授权的一些必要知识点</h3>

<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权官网</a></p>
<p>这里的信息基本都是来自上面的官网信息的。首先，想要获取授权，一定要有一个服务号(300一年的认证，必不可少)。其次认证之后。需要在公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<h4 id="关于网页授权的两种scope的区别说明"><a href="#关于网页授权的两种scope的区别说明" class="headerlink" title="关于网页授权的两种scope的区别说明"></a>关于网页授权的两种scope的区别说明</h4><ul>
<li>以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid</li>
<li>以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的</li>
</ul>
<p>项目中我们采用下面这个。</p>
<p>用户授权获取code的方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</span><br></pre></td></tr></table></figure></p>
<p>这里需要突出强调的是回调的地址 -需要对回调的地址做urlEncode处理，其他的参数配置好，当我们点击上述链接的时候，微信会自动重定向到我们写入的回调地址。而不需要用户自己ajax请求。</p>
<p>回调的同时我们会取到code ，这个时候，第二步：通过code换取网页授权access_token</p>
<p>第三步：刷新access_token（如果需要）</p>
<p>第四步：拉取用户信息(需scope为 snsapi_userinfo) 以access_token和openid为基础去取信息。</p>
<p>需要测试的话，我们可以使用微信公众号给出的测试账号来进行测试。<br>拿到你自己的测试账号，配置参数。<br><img src="https://upload-images.jianshu.io/upload_images/5531021-04072b632f1711db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>关注你自己的测试公众号就可以进行测试。以上就是微信web开发的一些个人经验。在这里记录。学习了也增长了知识，果然上手项目才是学习和入门最好的方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/dva的进一步学习创建UCRD项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KrisLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krislee的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/dva的进一步学习创建UCRD项目/" itemprop="url">dva的进一步学习创建UCRD项目(简书版)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T01:07:50+08:00">
                2018-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h2 id="划分结构"><a href="#划分结构" class="headerlink" title="划分结构"></a>划分结构</h2><h2 id="设计model"><a href="#设计model" class="headerlink" title="设计model"></a>设计model</h2><p>在了解了项目基本的结构划分以后，我们将要开始设计 model，在设计 model 之前，我们来回顾一下我们需要做的项目是什么样的：</p>
<p><img src="https://cloud.githubusercontent.com/assets/1179603/17655205/dfde2f4e-62dd-11e6-9c91-657ee4c17b91.png" alt="pic1"></p>
<h3 id="Model的抽象"><a href="#Model的抽象" class="headerlink" title="Model的抽象"></a>Model的抽象</h3><p>从设计稿中我们可以看出，这部分功能基本是围绕 以用户数据为基础 的操作，其中包含：</p>
<ol>
<li>用户信息的展示（查询）</li>
<li>用户信息的操作（增加，删除，修改</li>
</ol>
<p>我们在项目的model 下新增一个users.js</p>
<p>我们可以按照两个纬度的东西来看：1. 按照数据纬度 2. 按照业务纬度</p>
<h4 id="数据纬度"><a href="#数据纬度" class="headerlink" title="数据纬度"></a>数据纬度</h4><p>按照数据维度的 model 设计原则就是抽离数据本身以及相关操作的方法，比如在本例的 users ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * model users.js的设计、</span><br><span class="line"> * 按照数据维度的 model 设计原则就是抽离数据本身以及相关操作的方法，</span><br><span class="line"> */</span><br><span class="line"> export default &#123;</span><br><span class="line">     namespace:&apos;users&apos;,</span><br><span class="line">     state:&#123;</span><br><span class="line">         list:[],</span><br><span class="line">         total:null,</span><br><span class="line">     &#125;,</span><br><span class="line">     effects:&#123;</span><br><span class="line">        *query()&#123;&#125;,</span><br><span class="line">		*create()&#123;&#125;,</span><br><span class="line">		// 因为delete是关键字</span><br><span class="line">		*&apos;delete&apos;()&#123;&#125;,</span><br><span class="line">		*update()&#123;&#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     reducers: &#123;</span><br><span class="line">		querySuccess()&#123;&#125;,</span><br><span class="line">		createSuccess()&#123;&#125;,</span><br><span class="line">		deleteSuccess()&#123;&#125;,</span><br><span class="line">		updateSuccess()&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果你写过后台代码，你会发现这跟我们常常写的后台接口是很类似的，只关心数据本身，至于在使用 users model 的组件中所遇到的状态管理等信息跟 model 无关，而是作为组件自身的state维护。</p>
<p>这种设计方式使得 model 很纯粹，在设计通用数据信息 model 的时候比较适用，比如当前用户登陆信息等数据 model。但是在数据跟业务状态交互比较紧密，数据不是那么独立的时候会有些不那么方便，因为在数据跟业务状态紧密相连的场景下，将状态放到 model 里面维护会使得我们的代码更加清晰可控，而这种方式就是下面将要介绍的<em>业务维度</em>方式的设计。</p>
<h4 id="业务纬度"><a href="#业务纬度" class="headerlink" title="业务纬度"></a>业务纬度</h4><p>按照业务维度的 model 设计，则是将数据以及使用强关联数据的组件中的状态统一抽象成 model 的方法，(<strong>更多会考虑交互上的方法，比如loading 的展示或者消失，modal的展示或者消失，在这个例子中，我们的组件会使用ant-design中的设计</strong>)在本例中，users model设计如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * model users.js的设计、</span><br><span class="line"> * 按照数据维度的 model 设计原则就是抽离数据本身以及相关操作的方法，</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> export default &#123;</span><br><span class="line">     namespace:&apos;users&apos;,</span><br><span class="line">     state:&#123;</span><br><span class="line">         list:[],</span><br><span class="line">         total:null,</span><br><span class="line">         loading: false, // 控制加载状态</span><br><span class="line">         current: null, // 当前分页信息</span><br><span class="line">         currentItem: &#123;&#125;, // 当前操作的用户对象</span><br><span class="line">         modalVisible: false, // 弹出窗的显示状态</span><br><span class="line">         modalType: &apos;create&apos;, // 弹出窗的类型（添加用户，编辑用户）</span><br><span class="line">     &#125;,</span><br><span class="line">     effects:&#123;</span><br><span class="line">        *query()&#123;&#125;,</span><br><span class="line">		*create()&#123;&#125;,</span><br><span class="line">		// 因为delete是关键字</span><br><span class="line">		*&apos;delete&apos;()&#123;&#125;,</span><br><span class="line">		*update()&#123;&#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     reducers: &#123;</span><br><span class="line">        //业务纬度的设计(更多会考虑交互上的问题)</span><br><span class="line">        showLoading()&#123;&#125;, // 控制加载状态的 reducer</span><br><span class="line">		showModal()&#123;&#125;, // 控制 Modal 显示状态的 reducer</span><br><span class="line">		hideModal()&#123;&#125;,</span><br><span class="line">        //数据纬度的设计</span><br><span class="line">		querySuccess()&#123;&#125;,</span><br><span class="line">		createSuccess()&#123;&#125;,</span><br><span class="line">		deleteSuccess()&#123;&#125;,</span><br><span class="line">		updateSuccess()&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件设计方法"><a href="#组件设计方法" class="headerlink" title="组件设计方法"></a>组件设计方法</h2><p>在初步确定了 model 的设计方法以后，让我们来看看如何设计 dva 中的 React 组件。</p>
<p>React 应用是由一个个独立的 Component 组成的，我们在拆分 Component 的过程中要尽量让<strong>每个 Component 专注做自己的事</strong>。(这也是react的核心思想，组件化的思想，在设计和使用的时候，我们拆分组件，让组件做自己的事情。)</p>
<p><em>一般来说，我们的组件有两种设计：</em></p>
<ul>
<li>Container Component</li>
<li>Presentational Component</li>
</ul>
<p><strong>Container Component</strong>一般指的是具有<em>监听数据</em>行为的组件，一般来说它们的职责是绑定相关联的 model 数据。以数据容器的角色包含其它子组件。</p>
<p><strong>通常的写法为：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// dva 的 connect 方法可以将组件和数据关联在一起</span><br><span class="line">import &#123; connect &#125; from &apos;dva&apos;;</span><br><span class="line"></span><br><span class="line">// 组件本身</span><br><span class="line">const MyComponent = (props)=&gt;&#123;&#125;;</span><br><span class="line">MyComponent.propTypes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 监听属性，建立组件和数据的映射关系</span><br><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  return &#123;...state.data&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关联 model</span><br><span class="line">export default connect(mapStateToProps)(MyComponent);</span><br></pre></td></tr></table></figure>
<p><strong>Presentational Component</strong> 的名称已经说明了它的职责，展示形组件，一般也称作：Dumb Component，它不会关联订阅 model 上的数据，而所需数据的传递则是通过 props 传递到组件内部。</p>
<p>通常写法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 组件本身</span><br><span class="line">// 所需要的数据通过 Container Component 通过 props 传递下来</span><br><span class="line">const MyComponent = (props)=&gt;&#123;&#125;</span><br><span class="line">MyComponent.propTypes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 并不会监听数据</span><br><span class="line">export default MyComponent;</span><br></pre></td></tr></table></figure>
<h5 id="那么拆分组件有什么好处呢？"><a href="#那么拆分组件有什么好处呢？" class="headerlink" title="那么拆分组件有什么好处呢？"></a>那么拆分组件有什么好处呢？</h5><ul>
<li>让项目的数据处理更加集中；</li>
<li>让组件高内聚低耦合，更加聚焦；</li>
</ul>
<p>试想如果每个组件都去订阅数据 model，那么一方面组件本身跟 model 耦合太多，另一方面代码过于零散，到处都在操作数据，会带来后期维护的烦恼。</p>
<p>除了写法上订阅数据的区别以外，在设计思路上两个组件也有很大不同。 Presentational Component是独立的纯粹的，这方面很好的例子，大家可以参考 ant.design UI组件的React实现 ，每个组件跟业务数据并没有耦合关系，只是完成自己独立的任务，需要的数据通过 props 传递进来，需要操作的行为通过接口暴露出去。 而 Container Component 更像是状态管理器，它表现为一个容器，订阅子组件需要的数据，组织子组件的交互逻辑和展示。</p>
<h2 id="组件设计实践"><a href="#组件设计实践" class="headerlink" title="组件设计实践"></a>组件设计实践</h2><p>首先啊，咱们需要先创建路由，设置 Users Router Container 的访问路径，并且在 /routes/ 下创建我们的组件文件 Users.jsx。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// .src/router.js</span><br><span class="line">import React, &#123; PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; Router, Route &#125; from &apos;dva/router&apos;;</span><br><span class="line">import Users from &apos;./routes/Users&apos;;</span><br><span class="line"></span><br><span class="line">export default function(&#123; history &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Route path=&quot;/users&quot; component=&#123;Users&#125; /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后创建路由容器组件users.jsx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// .src/routes/Users.jsx</span><br><span class="line">import React, &#123; PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Users() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;User Router Component&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Users.propTypes = &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Users;</span><br></pre></td></tr></table></figure>
<h3 id="Users-Container-Component-的设计"><a href="#Users-Container-Component-的设计" class="headerlink" title="Users Container Component 的设计"></a>Users Container Component 的设计</h3><p>我们采用自顶向下的设计方法，修改 ./src/routes/Users.jsx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// ./src/routes/Users.jsx</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// Users 的 Presentational Component</span><br><span class="line">// 暂时都没实现</span><br><span class="line">import UserList from &apos;../components/Users/UserList&apos;;</span><br><span class="line">import UserSearch from &apos;../components/Users/UserSearch&apos;;</span><br><span class="line">import UserModal from &apos;../components/Users/UserModal&apos;;</span><br><span class="line"></span><br><span class="line">// 引入对应的样式</span><br><span class="line">// 可以暂时新建一个空的</span><br><span class="line">import styles from &apos;./Users.less&apos;;</span><br><span class="line"></span><br><span class="line">function Users() &#123;</span><br><span class="line"></span><br><span class="line">  const userSearchProps = &#123;&#125;;</span><br><span class="line">  const userListProps = &#123;&#125;;</span><br><span class="line">  const userModalProps = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;styles.normal&#125;&gt;</span><br><span class="line">      &#123;/* 用户筛选搜索框 */&#125;</span><br><span class="line">      &lt;UserSearch &#123;...userSearchProps&#125; /&gt;</span><br><span class="line">      &#123;/* 用户信息展示列表 */&#125;</span><br><span class="line">      &lt;UserList &#123;...userListProps&#125; /&gt;</span><br><span class="line">      &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125;</span><br><span class="line">      &lt;UserModal &#123;...userModalProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Users;</span><br></pre></td></tr></table></figure>
<p><strong>创建UserList,UserSearch,UserModal这三个组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ./src/components/Users/UserSearch.jsx</span><br><span class="line">import React, &#123; PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">export default ()=&gt;&lt;div&gt;user search&lt;/div&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ./src/components/Users/UserList.jsx</span><br><span class="line">import React, &#123; PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">export default ()=&gt;&lt;div&gt;user list&lt;/div&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ./src/components/Users/UserModal.jsx</span><br><span class="line">import React, &#123; PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">export default ()=&gt;&lt;div&gt;user modal&lt;/div&gt;;</span><br></pre></td></tr></table></figure>
<p>这样如果你到现在都是成功的话，那么访问本地的地址，如：<a href="http://localhost:8000/#/users" target="_blank" rel="noopener">http://localhost:8000/#/users</a> 应该是展示</p>
<p>user search<br>user list<br>user modal</p>
<p>这样的数据的。</p>
<p>值得注意的地方，通常定义我们的组件一般有三种方式：</p>
<p>// 1. 传统写法<br>const App = React.createClass({});</p>
<p>// 2. es6 的写法<br>class App extends React.Component({});</p>
<p>// 3. stateless 的写法（我们推荐的写法）<br>const App = (props) =&gt; ({});</p>
<p>其中第1种是我们不推荐的写法，第2种是在你的组件涉及 react 的生命周期方法的时候采用这种写法，而第3种则是我们一般推荐的写法。详细内容可以参看<a href="https://reactjs.org/docs/components-and-props.html#stateless-functions" target="_blank" rel="noopener">Stateless Functions</a>。</p>
<h3 id="UserList-组件"><a href="#UserList-组件" class="headerlink" title="UserList 组件"></a>UserList 组件</h3><p>暂时放下<usersearch>和<usermodal>，先来看看<userlist>的实现，这是一个用户的展示列表，我们期望只需要把数据传入进去，修改 ./src/components/Users/UserList.jsx：</userlist></usermodal></usersearch></p>
<p>这里我们采用antd UI组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Table, message, Popconfirm &#125; from &apos;antd&apos;;</span><br></pre></td></tr></table></figure>
<p>这里我们不难发现。我们使用Table组件，因此需要传入一些参数。这里我们使用了stateless的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// ./src/components/Users/UserList.jsx</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 采用antd的UI组件</span><br><span class="line">import &#123; Table, message, Popconfirm &#125; from &apos;antd&apos;;</span><br><span class="line"></span><br><span class="line">// 采用 stateless 的写法</span><br><span class="line">// export default ()=&gt;&lt;div&gt;user list&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const UserList = (&#123;</span><br><span class="line">    total,</span><br><span class="line">    current,</span><br><span class="line">    loading,</span><br><span class="line">    dataSource,</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    const columns = [&#123;</span><br><span class="line">        title: &apos;姓名&apos;,</span><br><span class="line">        dataIndex: &apos;name&apos;,</span><br><span class="line">        key: &apos;name&apos;,</span><br><span class="line">        render: (text) =&gt; &lt;a href=&quot;#&quot;&gt;&#123;text&#125;&lt;/a&gt;,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        title: &apos;年龄&apos;,</span><br><span class="line">        dataIndex: &apos;age&apos;,</span><br><span class="line">        key: &apos;age&apos;,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        title: &apos;住址&apos;,</span><br><span class="line">        dataIndex: &apos;address&apos;,</span><br><span class="line">        key: &apos;address&apos;,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        title: &apos;操作&apos;,</span><br><span class="line">        key: &apos;operation&apos;,</span><br><span class="line">        render: (text, record) =&gt; (</span><br><span class="line">          &lt;p&gt;</span><br><span class="line">            &lt;a onClick=&#123;()=&gt;&#123;&#125;&#125;&gt;编辑&lt;/a&gt;</span><br><span class="line">            &amp;nbsp;</span><br><span class="line">            &lt;Popconfirm title=&quot;确定要删除吗？&quot; onConfirm=&#123;()=&gt;&#123;&#125;&#125;&gt;</span><br><span class="line">              &lt;a&gt;删除&lt;/a&gt;</span><br><span class="line">            &lt;/Popconfirm&gt;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">        ),</span><br><span class="line">      &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //定义分页对象</span><br><span class="line"></span><br><span class="line">      const pagination = &#123;</span><br><span class="line">        total,</span><br><span class="line">        current,</span><br><span class="line">        pageSize: 10,</span><br><span class="line">        onChange: ()=&gt;&#123;&#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Table</span><br><span class="line">            columns=&#123;columns&#125;</span><br><span class="line">            dataSource=&#123;dataSource&#125;</span><br><span class="line">            loading=&#123;loading&#125;</span><br><span class="line">            rowKey=&#123;record =&gt; record.id&#125;</span><br><span class="line">            pagination=&#123;pagination&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export default UserList;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，由于我们采用了 antd，所以我们需要在我们的代码中添加样式，可以在 ./src/index.js 中添加一行:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;antd/dist/antd.css&apos;</span><br></pre></td></tr></table></figure>
<p>接下来。由于我们传递了 columns ，dataSource ，loading ，rowKey，pagination等props，因此，我们需要制造一些假数据传入，使得页面更真实。</p>
<p>在routes/Users.jsx中，新增假数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const userListProps = &#123;</span><br><span class="line">  //默认先传一些假数据</span><br><span class="line">  total: 3,</span><br><span class="line">  current: 1,</span><br><span class="line">  loading: false,</span><br><span class="line">  dataSource: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;张三&apos;,</span><br><span class="line">      age: 23,</span><br><span class="line">      address: &apos;成都&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;李四&apos;,</span><br><span class="line">      age: 24,</span><br><span class="line">      address: &apos;杭州&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;王五&apos;,</span><br><span class="line">      age: 25,</span><br><span class="line">      address: &apos;上海&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最终展现的效果图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5531021-64ef72a9abb9749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h3 id="组件设计小结"><a href="#组件设计小结" class="headerlink" title="组件设计小结"></a>组件设计小结</h3><p>虽然我们上面实现的代码很简单，但是已经包含了组件设计的主要思路，可以看到 UserList 组件是一个很纯粹的 Presentation Component，所需要的数据以及状态是通过 Users Router Component 传递的，我们现在还是用的静态数据，接下来我们来看看如何在 model 创建 reducer 来将我们的数据抽象出来。</p>
<h2 id="添加Reducer"><a href="#添加Reducer" class="headerlink" title="添加Reducer"></a>添加Reducer</h2><p>如果对redux有所了解的话，那么就能很好的理解 Reducer，在这里我做个不恰当的比方，好比李云龙负责带兵打仗，那么李云龙在整个react中其实是负责展示这一块，我们知道军队还有后勤这一块，那么赵政委就是负责后勤这一块，告诉李云龙，这里不需要你负责，你只要展示，他们如果展示，如果操控我来负责。其实赵政委就是redux 。而Reducer 是主要控制状态改变 也就是我们所说的 state，而发出改变的命令是action来操控的。这也就有了dispatch的概念，dispatch其实就是命令。当然之后react-redux优化了这一块，使得我们在改变数据源的时候更加的方便。</p>
<h3 id="给UserModal添加Reducers"><a href="#给UserModal添加Reducers" class="headerlink" title="给UserModal添加Reducers"></a>给UserModal添加Reducers</h3><p>回到我们之前的 /models/users.js，我们在之前已经定义好了它的 state，接下来我们看看如何根据新的数据来修改本身的 state，这就是 reducers 要做的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  namespace: &apos;users&apos;,</span><br><span class="line"></span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: null,</span><br><span class="line">    loading: false, // 控制加载状态</span><br><span class="line">    current: null, // 当前分页信息</span><br><span class="line">    currentItem: &#123;&#125;, // 当前操作的用户对象</span><br><span class="line">    modalVisible: false, // 弹出窗的显示状态</span><br><span class="line">    modalType: &apos;create&apos;, // 弹出窗的类型（添加用户，编辑用户）</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query()&#123;&#125;,</span><br><span class="line">    *create()&#123;&#125;,</span><br><span class="line">    *&apos;delete&apos;()&#123;&#125;,</span><br><span class="line">    *update()&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    showLoading()&#123;&#125;, // 控制加载状态的 reducer</span><br><span class="line">    showModal()&#123;&#125;, // 控制 Modal 显示状态的 reducer</span><br><span class="line">    hideModal()&#123;&#125;,</span><br><span class="line">    // 使用静态数据返回</span><br><span class="line">    querySuccess(state)&#123;</span><br><span class="line">      const mock = &#123;</span><br><span class="line">        total: 3,</span><br><span class="line">        current: 1,</span><br><span class="line">        loading: false,</span><br><span class="line">        list: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            name: &apos;张三&apos;,</span><br><span class="line">            age: 23,</span><br><span class="line">            address: &apos;成都&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            name: &apos;李四&apos;,</span><br><span class="line">            age: 24,</span><br><span class="line">            address: &apos;杭州&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: 3,</span><br><span class="line">            name: &apos;王五&apos;,</span><br><span class="line">            age: 25,</span><br><span class="line">            address: &apos;上海&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line">      return &#123;...state, ...mock, loading: false&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    createSuccess()&#123;&#125;,</span><br><span class="line">    deleteSuccess()&#123;&#125;,</span><br><span class="line">    updateSuccess()&#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把之前 UserList 组件中模拟的静态数据，移动到了 reducers 中，通过调用 users/query/success 这个 reducer，我们就可以将 Users Model 的数据变成静态数据，那么我们如何调用这个 reducer，能够让这个数据传入 UserList 组件呢，接下来需要做的是：关联Model。</p>
<h3 id="关联Model"><a href="#关联Model" class="headerlink" title="关联Model"></a>关联Model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// ./src/routes/Users.jsx</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 引入 connect 工具函数</span><br><span class="line">import &#123; connect &#125; from &apos;dva&apos;;</span><br><span class="line"></span><br><span class="line">// Users 的 Presentational Component</span><br><span class="line">// 暂时都没实现</span><br><span class="line">import UserList from &apos;../components/Users/UserList&apos;;</span><br><span class="line">import UserSearch from &apos;../components/Users/UserSearch&apos;;</span><br><span class="line">import UserModal from &apos;../components/Users/UserModal&apos;;</span><br><span class="line"></span><br><span class="line">// 引入对应的样式</span><br><span class="line">// 可以暂时新建一个空的</span><br><span class="line">import styles from &apos;./Users.less&apos;;</span><br><span class="line"></span><br><span class="line">function Users(&#123; location, dispatch, users &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  const &#123;</span><br><span class="line">    loading, list, total, current,</span><br><span class="line">    currentItem, modalVisible, modalType</span><br><span class="line">    &#125; = users;</span><br><span class="line"></span><br><span class="line">  const userSearchProps=&#123;&#125;;</span><br><span class="line">  const userListProps=&#123;</span><br><span class="line">		dataSource: list,</span><br><span class="line">		total,</span><br><span class="line">		loading,</span><br><span class="line">		current,</span><br><span class="line">	&#125;;</span><br><span class="line">  const userModalProps=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;styles.normal&#125;&gt;</span><br><span class="line">      &#123;/* 用户筛选搜索框 */&#125;</span><br><span class="line">      &lt;UserSearch &#123;...userSearchProps&#125; /&gt;</span><br><span class="line">      &#123;/* 用户信息展示列表 */&#125;</span><br><span class="line">      &lt;UserList &#123;...userListProps&#125; /&gt;</span><br><span class="line">      &#123;/* 添加用户 &amp; 修改用户弹出的浮层 */&#125;</span><br><span class="line">      &lt;UserModal &#123;...userModalProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Users.propTypes = &#123;</span><br><span class="line">  users: PropTypes.object,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 指定订阅数据，这里关联了 users</span><br><span class="line">function mapStateToProps(&#123; users &#125;) &#123;</span><br><span class="line">  return &#123;users&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 建立数据关联关系</span><br><span class="line">export default connect(mapStateToProps)(Users);</span><br></pre></td></tr></table></figure>
<p>在之前的 组件设计 中讲到了 Presentational Component 的设计概念，在订阅了数据以后，就可以通过 props 访问到 model 的数据了，而 UserList 展示组件的数据，也是 Container Component 通过 props 传递的过来的。</p>
<p>组件和 model 建立了关联关系以后，如何在组件中获取 reduers 的数据呢，或者如何调用 reducers呢，就是需要发起一个 action。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>actions 的概念跟 reducers 一样，也是来自于 dva 封装的 redux，表达的概念是发起一个修改数据的行为，主要的作用是传递信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">	type: &apos;&apos;, // action 的名称，与 reducers（effects）对应</span><br><span class="line">	... // 调用时传递的参数，在 reducers（effects）可以获取</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是：action的名称（type）如果是在 model 以外调用需要添加 namespace。</p>
</blockquote>
<p>回到例子中，目前传入 UserList 组件的只是默认空数据，那么如何调用 reducers 获取刚才定义的静态数据呢？发起一个 actions：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">	type: &apos;users/querySuccess&apos;, // 调用一个actions</span><br><span class="line">	payload: &#123;&#125;, // 调用时传递的参数</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>知道了如何发起一个 action，那么剩下的就是发起的时机了，通常我们建议在组件内部的生命周期发起，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">	this.props.dispatch(&#123;</span><br><span class="line">		type: &apos;model/action&apos;,</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在本例中采用另一种发起 action 的场景，在本例中获取用户数据信息的时机就是访问 /users/ 这个页面，所以我们可以监听路由信息，只要路径是 /users/ 那么我们就会发起 action，获取用户数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// ./src/models/users.js</span><br><span class="line">import &#123; hashHistory &#125; from &apos;dva/router&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  namespace: &apos;users&apos;,</span><br><span class="line"></span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: null,</span><br><span class="line">    loading: false, // 控制加载状态</span><br><span class="line">    current: null, // 当前分页信息</span><br><span class="line">    currentItem: &#123;&#125;, // 当前操作的用户对象</span><br><span class="line">    modalVisible: false, // 弹出窗的显示状态</span><br><span class="line">    modalType: &apos;create&apos;, // 弹出窗的类型（添加用户，编辑用户）</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // Quick Start 已经介绍过 subscriptions 的概念，这里不在多说</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      history.listen(location =&gt; &#123;</span><br><span class="line">        if (location.pathname === &apos;/users&apos;) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: &apos;querySuccess&apos;,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query()&#123;&#125;,</span><br><span class="line">    *create()&#123;&#125;,</span><br><span class="line">    *&apos;delete&apos;()&#123;&#125;,</span><br><span class="line">    *update()&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    showLoading()&#123;&#125;, // 控制加载状态的 reducer</span><br><span class="line">    showModal()&#123;&#125;, // 控制 Modal 显示状态的 reducer</span><br><span class="line">    hideModal()&#123;&#125;,</span><br><span class="line">    // 使用静态数据返回</span><br><span class="line">    querySuccess(state)&#123;</span><br><span class="line">      const mock = &#123;</span><br><span class="line">        total: 3,</span><br><span class="line">        current: 1,</span><br><span class="line">        loading: false,</span><br><span class="line">        list: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;张三&apos;,</span><br><span class="line">            age: 23,</span><br><span class="line">            address: &apos;成都&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;李四&apos;,</span><br><span class="line">            age: 24,</span><br><span class="line">            address: &apos;杭州&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;王五&apos;,</span><br><span class="line">            age: 25,</span><br><span class="line">            address: &apos;上海&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line">      return &#123;...state, ...mock, loading: false&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    createSuccess()&#123;&#125;,</span><br><span class="line">    deleteSuccess()&#123;&#125;,</span><br><span class="line">    updateSuccess()&#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在浏览器访问 /users 路径的时候就会发起一个 action，数据准备完毕，别忘了回到 index.js 中，添加我们的 models：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// ./src/index.js</span><br><span class="line">import &apos;./index.html&apos;;</span><br><span class="line">import &apos;./index.less&apos;;</span><br><span class="line">import dva, &#123; connect &#125; from &apos;dva&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;antd/dist/antd.css&apos;;</span><br><span class="line"></span><br><span class="line">// 1. Initialize</span><br><span class="line">const app = dva();</span><br><span class="line"></span><br><span class="line">// 2. Model</span><br><span class="line">app.model(require(&apos;./models/users.js&apos;));</span><br><span class="line"></span><br><span class="line">// 3. Router</span><br><span class="line">app.router(require(&apos;./router&apos;));</span><br><span class="line"></span><br><span class="line">// 4. Start</span><br><span class="line">app.start(document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>
<p>这样我们依旧可以看到如下的效果:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5531021-64ef72a9abb9749c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这个例子中，我们在 合适的时机（进入 /users/ ）发起（dispatch）了一个 action，修改了 model 的数据，并且通过 Container Components 关联了 model，通过 props 传递到 Presentation Components，组件成功显示。如果你想了解更多关于 reducers &amp; actions 的信息，可以参看 redux。</p>
<h2 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h2><p>在之前的教程中，我们已经完成了静态数据的操作，但是在真实场景，数据都是从服务器来的，我们需要发起异步请求，在请求回来以后设置数据，更新 state，那么在 dva 中，这一切是怎么操作的呢，首先我们先来简单了解一下 Effects。</p>
<p>Effects 来源于 dva 封装的底层库 redux-sagas 的概念，主要指的是处理 Side Effects ，指的是副作用（源于函数式编程），在这里可以简单理解成异步操作，所以我们是不是可以理解成 Reducers 处理同步，Effects 处理异步？这么理解也没有问题，但是要认清 Reducers 的本质是修改 model 的 state，而 Effects 主要是 控制数据流程 ，所以最终往往我们<strong>在 Effects 中会调用 Reducers</strong>。</p>
<h3 id="给Users-Model添加Effects"><a href="#给Users-Model添加Effects" class="headerlink" title="给Users Model添加Effects"></a>给Users Model添加Effects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// ./src/models/users.js</span><br><span class="line">import &#123; hashHistory &#125; from &apos;dva/router&apos;;</span><br><span class="line">//import &#123; create, remove, update, query &#125; from &apos;../services/users&apos;;</span><br><span class="line"></span><br><span class="line">// 处理异步请求</span><br><span class="line">import request from &apos;../utils/request&apos;;</span><br><span class="line">import qs from &apos;qs&apos;;</span><br><span class="line">async function query(params) &#123;</span><br><span class="line">  return request(`/api/users?$&#123;qs.stringify(params)&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  namespace: &apos;users&apos;,</span><br><span class="line"></span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [],</span><br><span class="line">    total: null,</span><br><span class="line">    loading: false, // 控制加载状态</span><br><span class="line">    current: null, // 当前分页信息</span><br><span class="line">    currentItem: &#123;&#125;, // 当前操作的用户对象</span><br><span class="line">    modalVisible: false, // 弹出窗的显示状态</span><br><span class="line">    modalType: &apos;create&apos;, // 弹出窗的类型（添加用户，编辑用户）</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      history.listen(location =&gt; &#123;</span><br><span class="line">        if (location.pathname === &apos;/users&apos;) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: &apos;query&apos;,</span><br><span class="line">            payload: &#123;&#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  effects: &#123;</span><br><span class="line">    *query(&#123; payload &#125;, &#123; select, call, put &#125;) &#123;</span><br><span class="line">      yield put(&#123; type: &apos;showLoading&apos; &#125;);</span><br><span class="line">      const &#123; data &#125; = yield call(query);</span><br><span class="line">      if (data) &#123;</span><br><span class="line">        yield put(&#123;</span><br><span class="line">          type: &apos;querySuccess&apos;,</span><br><span class="line">          payload: &#123;</span><br><span class="line">            list: data.data,</span><br><span class="line">            total: data.page.total,</span><br><span class="line">            current: data.page.current</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    *create()&#123;&#125;,</span><br><span class="line">    *&apos;delete&apos;()&#123;&#125;,</span><br><span class="line">    *update()&#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    showLoading(state, action)&#123;</span><br><span class="line">      return &#123; ...state, loading: true &#125;;</span><br><span class="line">    &#125;, // 控制加载状态的 reducer</span><br><span class="line">    showModal()&#123;&#125;, // 控制 Modal 显示状态的 reducer</span><br><span class="line">    hideModal()&#123;&#125;,</span><br><span class="line">    // 使用服务器数据返回</span><br><span class="line">    querySuccess(state, action)&#123;</span><br><span class="line">      return &#123;...state, ...action.payload, loading: false&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    createSuccess()&#123;&#125;,</span><br><span class="line">    deleteSuccess()&#123;&#125;,</span><br><span class="line">    updateSuccess()&#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们需要增加 <em>query 第二个参数 </em>query({ payload }, { select, call, put }) ，其中 call 和 put 是 dva 提供的方便操作 effects 的函数，简单理解 call 是调用执行一个函数而 put 则是相当于 dispatch 执行一个 action，而 select 则可以用来访问其它 model，更多可以参看 <a href="https://github.com/superRaytin/redux-saga-in-chinese" target="_blank" rel="noopener">redux-saga-in-chinese</a>。</p>
<p>而在 query 函数里面，可以看到我们处理异步的方式跟同步一样，所以能够很好的控制异步流程，这也是我们使用 Effects 的原因，关于相关的更多内容可以参看 Generator 函数的含义与用法。</p>
<p>这里我们把请求的处理直接写在了代码里面，接下来我们需要把它拆分到 /services/ 里面统一处理</p>
<h2 id="定义Services"><a href="#定义Services" class="headerlink" title="定义Services"></a>定义Services</h2><p>之前我们已经：</p>
<ol>
<li>设计好了 model state -&gt; 抽象数据</li>
<li>完善了组件 -&gt; 完善展示</li>
<li>添加了 Reducers -&gt; 数据同步处理</li>
<li>添加了 Effects -&gt; 数据异步处理</li>
</ol>
<p>接下来就是将请求相关（与后台系统的交互）抽离出来，单独放到 /services/ 中，进行统一维护管理，所以我们只需要将之前定义在 Effects 的以下代码，移动到 /services/users.js 中即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import request from &apos;../utils/request&apos;;</span><br><span class="line"></span><br><span class="line">import qs from &apos;qs&apos;;</span><br><span class="line"></span><br><span class="line">export async function query(params) &#123;</span><br><span class="line">    return request(`/api/users?$&#123;qs.stringify(params)&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 users model 中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; query &#125; from &apos;../services/users&apos;;</span><br></pre></td></tr></table></figure>
<p>之后无论是更新，删除、添加等操作，跟用户相关的都可以统一放置在 /services/users.js 中。</p>
<p>没错，我们虽然有了接口，但是我们还没有数据，在 dva 中，我们配套的工具能够很方便的模拟数据，这样就可以脱离服务器复杂的环境进行模拟的本地调试开发。下面一节就会一起来看下，如何 mock 数据。</p>
<h2 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h2><p>我们采用了<a href="https://github.com/dora-js/dora-plugin-proxy" target="_blank" rel="noopener">dora-plugin-proxy</a>工具来完成了我们的数据 mock 功能。</p>
<h2 id="roadhog"><a href="#roadhog" class="headerlink" title="roadhog"></a>roadhog</h2><p>如果不用dora-plugin-proxy ，我们可以采用roadhog。Roadhog 是一个包含 dev、build 和 test 的命令行工具，他基于 react-dev-utils，和 create-react-app 的体验保持一致。你可以想象他为可配置版的 create-react-app。</p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>📦 开箱即用的 react 应用开发工具，内置 css-modules、babel、postcss、HMR 等</li>
<li>🚨 create-react-app 的体验</li>
<li>🐠 JSON 格式的 webpack 配置</li>
<li>✂️ mock</li>
<li>🔥 基于 jest 的 test，包括 UI 测试（基于 enzyme）</li>
</ul>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>目前不知是不是proxy 的问题，导致无法获取到请求到数据。先上传代码。该问题之后有空来解决。</p>
<p>参考的文档上，给出的源码已经更改，我的github上的代码是根据文档来的，但是无法获取到数据。</p>
<p><a href="https://github.com/krislee94/DVA_DEMO/tree/master/user-dashboard" target="_blank" rel="noopener">github地址</a>在这里。</p>
<h2 id="问题报错"><a href="#问题报错" class="headerlink" title="问题报错"></a>问题报错</h2><p><em>app.model: namespace should be defined</em></p>
<p><a href="https://github.com/dvajs/dva/issues/1624" target="_blank" rel="noopener">遇到的问题查询github的issue解决</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/superRaytin/redux-saga-in-chinese" target="_blank" rel="noopener">redux-sagas中文文档</a></p>
<p><a href="https://github.com/dvajs/dva-docs/blob/master/v1/zh-cn/tutorial/01-%E6%A6%82%E8%A6%81.md" target="_blank" rel="noopener">参考文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">KrisLee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/krislee94" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="lidazhoukris@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KrisLee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
